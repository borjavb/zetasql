//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// resolved_ast.proto GENERATED FROM resolved_ast.proto.template
syntax = "proto2";

package zetasql;

option java_package = "com.google.zetasql";
option java_multiple_files = true;
option java_outer_classname = "ZetaSQLResolvedAST";

option optimize_for = CODE_SIZE;

import "zetasql/public/proto/type_annotation.proto";
import "zetasql/public/type.proto";
import "zetasql/proto/function.proto";
import "zetasql/resolved_ast/serialization.proto";
import "zetasql/resolved_ast/resolved_ast_enums.proto";

// AnyResolvedNodeProto is a container that can hold at most one proto
// representation of a ResolvedNode
message AnyResolvedNodeProto {
  oneof node {
    AnyResolvedArgumentProto resolved_argument_node = 1;
    AnyResolvedExprProto resolved_expr_node = 2;
    AnyResolvedScanProto resolved_scan_node = 18;
    AnyResolvedStatementProto resolved_statement_node = 36;
  }
}

// Argument nodes are not self-contained nodes in the tree.  They exist
// only to describe parameters to another node (e.g. columns in an OrderBy).
// This node is here for organizational purposes only, to cluster these
// argument nodes.
message AnyResolvedArgumentProto {
  oneof node {
    ResolvedMakeProtoFieldProto resolved_make_proto_field_node = 14;
    ResolvedColumnHolderProto resolved_column_holder_node = 23;
    ResolvedComputedColumnProto resolved_computed_column_node = 32;
    ResolvedOrderByItemProto resolved_order_by_item_node = 33;
    ResolvedOutputColumnProto resolved_output_column_node = 34;
    ResolvedWithEntryProto resolved_with_entry_node = 52;
    ResolvedOptionProto resolved_option_node = 53;
    ResolvedWindowPartitioningProto resolved_window_partitioning_node = 54;
    ResolvedWindowOrderingProto resolved_window_ordering_node = 55;
    ResolvedWindowFrameProto resolved_window_frame_node = 56;
    ResolvedAnalyticFunctionGroupProto resolved_analytic_function_group_node = 57;
    ResolvedWindowFrameExprProto resolved_window_frame_expr_node = 58;
    ResolvedDMLValueProto resolved_dmlvalue_node = 59;
    ResolvedAssertRowsModifiedProto resolved_assert_rows_modified_node = 61;
    ResolvedInsertRowProto resolved_insert_row_node = 62;
    ResolvedUpdateItemProto resolved_update_item_node = 65;
    ResolvedPrivilegeProto resolved_privilege_node = 67;
    ResolvedArgumentDefProto resolved_argument_def_node = 77;
    ResolvedArgumentListProto resolved_argument_list_node = 79;
    ResolvedTVFArgumentProto resolved_tvfargument_node = 82;
    ResolvedFunctionSignatureHolderProto resolved_function_signature_holder_node = 84;
    ResolvedAggregateHavingModifierProto resolved_aggregate_having_modifier_node = 85;
    ResolvedColumnDefinitionProto resolved_column_definition_node = 91;
    ResolvedPrimaryKeyProto resolved_primary_key_node = 92;
    ResolvedGroupingSetProto resolved_grouping_set_node = 93;
    ResolvedSetOperationItemProto resolved_set_operation_item_node = 94;
    ResolvedIndexItemProto resolved_index_item_node = 96;
    ResolvedMergeWhenProto resolved_merge_when_node = 100;
    ResolvedUpdateArrayItemProto resolved_update_array_item_node = 102;
    ResolvedColumnAnnotationsProto resolved_column_annotations_node = 104;
    ResolvedGeneratedColumnInfoProto resolved_generated_column_info_node = 105;
    ResolvedModelProto resolved_model_node = 109;
    ResolvedForeignKeyProto resolved_foreign_key_node = 110;
    ResolvedCheckConstraintProto resolved_check_constraint_node = 113;
    AnyResolvedAlterActionProto resolved_alter_action_node = 116;
    ResolvedUnnestItemProto resolved_unnest_item_node = 126;
    ResolvedReplaceFieldItemProto resolved_replace_field_item_node = 128;
    ResolvedConnectionProto resolved_connection_node = 141;
    ResolvedExecuteImmediateArgumentProto resolved_execute_immediate_argument_node = 143;
  }
}

message ResolvedArgumentProto {
  optional ResolvedNodeProto parent = 1;

}

message AnyResolvedExprProto {
  oneof node {
    ResolvedLiteralProto resolved_literal_node = 3;
    ResolvedParameterProto resolved_parameter_node = 4;
    ResolvedExpressionColumnProto resolved_expression_column_node = 5;
    ResolvedColumnRefProto resolved_column_ref_node = 6;
    AnyResolvedFunctionCallBaseProto resolved_function_call_base_node = 7;
    ResolvedCastProto resolved_cast_node = 11;
    ResolvedMakeStructProto resolved_make_struct_node = 12;
    ResolvedMakeProtoProto resolved_make_proto_node = 13;
    ResolvedGetStructFieldProto resolved_get_struct_field_node = 15;
    ResolvedGetProtoFieldProto resolved_get_proto_field_node = 16;
    ResolvedSubqueryExprProto resolved_subquery_expr_node = 17;
    ResolvedDMLDefaultProto resolved_dmldefault_node = 60;
    ResolvedArgumentRefProto resolved_argument_ref_node = 78;
    ResolvedConstantProto resolved_constant_node = 103;
    ResolvedReplaceFieldProto resolved_replace_field_node = 129;
    ResolvedSystemVariableProto resolved_system_variable_node = 139;
  }
}

message ResolvedExprProto {
  optional ResolvedNodeProto parent = 1;

  optional TypeProto type = 2;
}

// Any literal value, including NULL literals.
// There is a special-cased constructor here that gets the type from the
// Value.
message ResolvedLiteralProto {
  optional ResolvedExprProto parent = 1;

  optional ValueWithTypeProto value = 2;
  // If true, then the literal is explicitly typed and cannot be used
  // for literal coercions.
  //
  // This exists mainly for resolver bookkeeping and should be ignored
  // by engines.
  optional bool has_explicit_type = 3;
  // Distinct ID of the literal, if it is a floating point value,
  // within the resolved AST. When coercing from floating point
  // to NUMERIC, the resolver uses the float_literal_id to find the
  // original image of the literal to avoid precision loss. An ID of 0
  // represents a literal without a cached image.
  optional int64 float_literal_id = 4;
}

message ResolvedParameterProto {
  optional ResolvedExprProto parent = 1;

  // If non-empty, the name of the parameter.
  //
  // A ResolvedParameter will have either a name or a position but not
  // both.
  optional string name = 2;
  // If non-zero, the 1-based position of the positional parameter.
  //
  // A ResolvedParameter will have either a name or a position but not
  // both.
  optional int64 position = 5;
  // If true, then the parameter has no specified type.
  //
  // This exists mainly for resolver bookkeeping and should be ignored
  // by engines.
  optional bool is_untyped = 3;
}

// This represents a column when analyzing a standalone expression.
// This is only used when the analyzer was called using AnalyzeExpression.
// Expression column names and types come from
// AnalyzerOptions::AddExpressionColumn.
// <name> will always be in lowercase.
message ResolvedExpressionColumnProto {
  optional ResolvedExprProto parent = 1;

  optional string name = 2;
}

// An expression referencing the value of some column visible in the
// current Scan node.
//
// If <is_correlated> is false, this must be a column visible in the Scan
// containing this expression, either because it was produced inside that
// Scan or it is on the <column_list> of some child of this Scan.
//
// If <is_correlated> is true, this references a column from outside a
// subquery that is visible as a correlated column inside.
// The column referenced here must show up on the parameters list for the
// subquery.  See ResolvedSubqueryExpr.
message ResolvedColumnRefProto {
  optional ResolvedExprProto parent = 1;

  optional ResolvedColumnProto column = 2;
  optional bool is_correlated = 3;
}

// A reference to a named constant.
message ResolvedConstantProto {
  optional ResolvedExprProto parent = 1;

  // The matching Constant from the Catalog.
  optional ConstantRefProto constant = 2;
}

// A reference to a system variable.
message ResolvedSystemVariableProto {
  optional ResolvedExprProto parent = 1;

  // Path to system variable.
  repeated string name_path = 2;
}

// Common base class for scalar and aggregate function calls.
message AnyResolvedFunctionCallBaseProto {
  oneof node {
    ResolvedFunctionCallProto resolved_function_call_node = 8;
    AnyResolvedNonScalarFunctionCallBaseProto resolved_non_scalar_function_call_base_node = 86;
  }
}

message ResolvedFunctionCallBaseProto {
  optional ResolvedExprProto parent = 1;

  // The matching Function from the Catalog.
  optional FunctionRefProto function = 2;
  // The concrete FunctionSignature reflecting the matching Function
  // signature and the function's resolved input <argument_list>.
  // The function has the mode AGGREGATE iff it is an aggregate
  // function, in which case this node must be either
  // ResolvedAggregateFunctionCall or ResolvedAnalyticFunctionCall.
  optional FunctionSignatureProto signature = 3;
  repeated AnyResolvedExprProto argument_list = 4;
  // If error_mode=SAFE_ERROR_MODE, and if this function call returns a
  // semantic error (based on input data, not transient server
  // problems), return NULL instead of an error. This is used for
  // functions called using SAFE, as in SAFE.FUNCTION(...).
  optional ResolvedFunctionCallBaseEnums.ErrorMode error_mode = 5;
}

// A regular function call.  The signature will always have mode SCALAR.
// Most scalar expressions show up as FunctionCalls using builtin signatures.
message ResolvedFunctionCallProto {
  optional ResolvedFunctionCallBaseProto parent = 1;

  // This contains optional custom information about a particular
  // function call.
  //
  // If some Function subclass requires computing additional
  // information at resolving time, that extra information can be
  // stored as a subclass of ResolvedFunctionCallInfo here.
  // For example, TemplatedSQLFunction stores the resolved template
  // body here as a TemplatedSQLFunctionCall.
  //
  // This field is ignorable because for most types of function calls,
  // there is no extra information to consider besides the arguments
  // and other fields from ResolvedFunctionCallBase.
  optional ResolvedFunctionCallInfoProto function_call_info = 2;
}

// Common base class for scalar and aggregate function calls.
message AnyResolvedNonScalarFunctionCallBaseProto {
  oneof node {
    ResolvedAggregateFunctionCallProto resolved_aggregate_function_call_node = 9;
    ResolvedAnalyticFunctionCallProto resolved_analytic_function_call_node = 10;
  }
}

message ResolvedNonScalarFunctionCallBaseProto {
  optional ResolvedFunctionCallBaseProto parent = 1;

  // Apply DISTINCT to the stream of input values before calling
  // function.
  optional bool distinct = 2;
  // Apply IGNORE/RESPECT NULLS filtering to the stream of input
  // values.
  optional ResolvedNonScalarFunctionCallBaseEnums.NullHandlingModifier null_handling_modifier = 3;
}

// An aggregate function call.  The signature always has mode AGGREGATE.
// This node only ever shows up as the outer function call in a
// ResolvedAggregateScan::aggregate_list.
message ResolvedAggregateFunctionCallProto {
  optional ResolvedNonScalarFunctionCallBaseProto parent = 1;

  // Apply HAVING MAX/MIN filtering to the stream of input values.
  optional ResolvedAggregateHavingModifierProto having_modifier = 5;
  // Apply ordering to the stream of input values before calling
  // function.
  repeated ResolvedOrderByItemProto order_by_item_list = 3;
  optional AnyResolvedExprProto limit = 4;
  // This contains optional custom information about a particular
  // function call. Functions may introduce subclasses of this class to
  // add custom information as needed on a per-function basis.
  //
  // This field is ignorable because for most types of function calls,
  // there is no extra information to consider besides the arguments
  // and other fields from ResolvedFunctionCallBase. However, for
  // example, the TemplateSQLFunction in
  // zetasql/public/templated_sql_function.h defines the
  // TemplatedSQLFunctionCall subclass which includes the
  // fully-resolved function body in context of the actual concrete
  // types of the arguments provided to the function call.
  optional ResolvedFunctionCallInfoProto function_call_info = 6;
}

// An analytic function call. The mode of the function is either AGGREGATE
// or ANALYTIC. This node only ever shows up as a function call in a
// ResolvedAnalyticFunctionGroup::analytic_function_list. Its associated
// window is not under this node but as a sibling of its parent node.
//
// <window_frame> can be NULL.
message ResolvedAnalyticFunctionCallProto {
  optional ResolvedNonScalarFunctionCallBaseProto parent = 1;

  optional ResolvedWindowFrameProto window_frame = 2;
}

// A cast expression, casting the result of an input expression to the
// target Type.
//
// Valid casts are defined in the CastHashMap (see cast.cc), which identifies
// valid from-Type, to-Type pairs.  Consumers can access it through
// GetZetaSQLCasts().
message ResolvedCastProto {
  optional ResolvedExprProto parent = 1;

  optional AnyResolvedExprProto expr = 2;
  // Whether to return NULL if the cast fails. This is set to true for
  // SAFE_CAST.
  optional bool return_null_on_error = 3;
}

// Construct a struct value.  <type> is always a StructType.
// <field_list> matches 1:1 with the fields in <type> position-wise.
// Each field's type will match the corresponding field in <type>.
message ResolvedMakeStructProto {
  optional ResolvedExprProto parent = 1;

  repeated AnyResolvedExprProto field_list = 2;
}

// Construct a proto value.  <type> is always a ProtoType.
// <field_list> is a vector of (FieldDescriptor, expr) pairs to write.
// <field_list> will contain all required fields, and no duplicate fields.
message ResolvedMakeProtoProto {
  optional ResolvedExprProto parent = 1;

  repeated ResolvedMakeProtoFieldProto field_list = 2;
}

// One field assignment in a ResolvedMakeProto expression.
// The type of expr will match with the zetasql type of the proto field.
// The type will be an array iff the field is repeated.
//
// For NULL values of <expr>, the proto field should be cleared.
//
// If any value of <expr> cannot be written into the field, this query
// should fail.
message ResolvedMakeProtoFieldProto {
  optional ResolvedArgumentProto parent = 1;

  optional FieldDescriptorRefProto field_descriptor = 2;
  // Provides the Format annotation that should be used when building
  // this field.  The annotation specifies both the ZetaSQL type and
  // the encoding format for this field.
  optional FieldFormat.Format format = 3;
  optional AnyResolvedExprProto expr = 4;
}

// Get the field in position <field_idx> (0-based) from <expr>, which has a
// STRUCT type.
message ResolvedGetStructFieldProto {
  optional ResolvedExprProto parent = 1;

  optional AnyResolvedExprProto expr = 2;
  optional int64 field_idx = 3;
}

message ResolvedGetProtoFieldProto {
  optional ResolvedExprProto parent = 1;

  optional AnyResolvedExprProto expr = 2;
  // The proto2 FieldDescriptor to extract.  This provides the tag
  // number and wire type.  Additional decoding may be necessary if any
  // of the other modifiers below are set.  Consumers should use those
  // ZetaSQL-computed modifiers rather than examining field
  // annotations directly.
  //
  // The field is an extension field iff
  // field_descriptor->is_extension() is true.  NOTE: The extended
  // descriptor's full_name must match the <expr>'s type's full_name,
  // but may not be the same Descriptor. Extension FieldDescriptors may
  // come from a different DescriptorPool.
  //
  // The field is required if field_descriptor->is_required().  If the
  // field is required and not present, an error should result.
  optional FieldDescriptorRefProto field_descriptor = 3;
  // Default value to use when the proto field is not set. The default
  // may be NULL (e.g. for proto2 fields with a use_defaults=false
  // annotation).
  //
  // This will not be filled in (the Value will be uninitialized) if
  // get_has_bit is true, or the field is required.
  //
  // If field_descriptor->is_required() and the field is not present,
  // the engine should return an error.
  //
  // If the <expr> itself returns NULL, then extracting a field should
  // also return NULL, unless <return_default_value_when_unset> is
  // true. In that case, the default value is returned.
  //
  // TODO Make un-ignorable after clients migrate to start
  // using it.
  optional ValueWithTypeProto default_value = 4;
  // Indicates whether to return a bool indicating if a value was
  // present, rather than return the value (or NULL). Never set for
  // repeated fields. This field cannot be set if
  // <return_default_value_when_unset> is true, and vice versa.
  // Expression type will be BOOL.
  optional bool get_has_bit = 5;
  // Provides the Format annotation that should be used when reading
  // this field.  The annotation specifies both the ZetaSQL type and
  // the encoding format for this field. This cannot be set when
  // get_has_bit is true.
  optional FieldFormat.Format format = 6;
  // Indicates that the default value should be returned if <expr> is
  // NULL.
  //
  // This can only be set for non-message fields. If the field is a
  // proto2 field, then it must be annotated with
  // zetasql.use_defaults=true. This cannot be set when <get_has_bit>
  // is true or the field is required.
  optional bool return_default_value_when_unset = 7;
}

// An argument to the REPLACE_FIELDS() function which specifies a field path
// and a value that this field will be set to. The field path to be modified
// can be constructed through the <struct_index_path> and <proto_field_path>
// fields. These vectors correspond to field paths in a STRUCT and PROTO,
// respectively. At least one of these vectors must be non-empty.
//
// If only <struct_index_path> is non-empty, then the field path only
// references top-level and nested struct fields.
//
// If only <proto_field_path> is non-empty, then the field path only
// references top-level and nested message fields.
//
// If both <struct_index_path> and <proto_field_path> are non-empty, then the
// field path should be expanded starting with <struct_index_path>. The last
// field in <struct_index_path> will be the proto from which the first field
// in <proto_field_path> is extracted.
//
// <expr> and the field to be modified must be the same type.
message ResolvedReplaceFieldItemProto {
  optional ResolvedArgumentProto parent = 1;

  // The value that the final field in <proto_field_path> will be set
  // to.
  //
  // If <expr> is NULL, the field will be unset. If <proto_field_path>
  // is a required field, the engine must return an error if it is set
  // to NULL.
  optional AnyResolvedExprProto expr = 2;
  // A vector of integers that denotes the path to a struct field that
  // will be modified. The integer values in this vector correspond to
  // field positions (0-based) in a STRUCT. If <proto_field_path>
  // is also non-empty, then the field corresponding to the last index
  // in this vector should be of proto type.
  repeated int64 struct_index_path = 3;
  // A vector of FieldDescriptors that denotes the path to a proto
  // field that will be modified. If <struct_index_path> is also
  // non-empty, then the first element in this vector should be a
  // subfield of the proto corresponding to the last element in
  // <struct_index_path>.
  repeated FieldDescriptorRefProto proto_field_path = 4;
}

// Represents a call to the REPLACE_FIELDS() function. This function
// can be used to copy a proto or struct, modify a few fields and
// output the resulting proto or struct. The SQL syntax for this
// function is REPLACE_FIELDS(<expr>, <replace_field_item_list>).
//
// See (broken link) for more detail.
message ResolvedReplaceFieldProto {
  optional ResolvedExprProto parent = 1;

  // The proto/struct to modify.
  optional AnyResolvedExprProto expr = 2;
  // The list of field paths to be modified along with their new
  // values.
  //
  // Engines must check at evaluation time that the modifications in
  // <replace_field_item_list> obey the following rules
  // regarding updating protos in ZetaSQL:
  // - Modifying a subfield of a NULL-valued proto-valued field is an
  //   error.
  // - Clearing a required field or subfield is an error.
  repeated ResolvedReplaceFieldItemProto replace_field_item_list = 3;
}

// A subquery in an expression (not a FROM clause).  The subquery runs
// in the context of a single input row and produces a single output value.
//
// Correlated subqueries can be thought of like functions, with a parameter
// list.  The <parameter_list> gives the set of ResolvedColumns from outside
// the subquery that are used inside.
//
// Inside the subquery, the only allowed references to values outside the
// subquery are to the named ColumnRefs listed in <parameter_list>.
// Any reference to one of these parameters will be represented as a
// ResolvedColumnRef with <is_correlated> set to true.
//
// These parameters are only visible through one level of expression
// subquery.  An expression subquery inside an expression has to list
// parameters again if parameters from the outer query are passed down
// further.  (This does not apply for table subqueries inside an expression
// subquery.  Table subqueries are never indicated in the resolved AST, so
// Scan nodes inside an expression query may have come from a nested table
// subquery, and they can still reference the expression subquery's
// parameters.)
//
// An empty <parameter_list> means that the subquery is uncorrelated.  It is
// permissable to run an uncorrelated subquery only once and reuse the result.
// TODO Do we want to specify semantics more firmly here?
//
// The semantics vary based on SubqueryType:
//   SCALAR
//     Usage: ( <subquery> )
//     If the subquery produces zero rows, the output value is NULL.
//     If the subquery produces exactly one row, that row is the output value.
//     If the subquery produces more than one row, raise a runtime error.
//
//   ARRAY
//     Usage: ARRAY( <subquery> )
//     The subquery produces an array value with zero or more rows, with
//     one array element per subquery row produced.
//
//   EXISTS
//     Usage: EXISTS( <subquery> )
//     The output type is always bool.  The result is true if the subquery
//     produces at least one row, and false otherwise.
//
//   IN
//     Usage: <in_expr> [NOT] IN ( <subquery> )
//     The output type is always bool.  The result is true when <in_expr> is
//     equal to at least one row, and false otherwise.  The <subquery> row
//     contains only one column, and the types of <in_expr> and the
//     subquery column must exactly match a built-in signature for the
//     '$equals' comparison function (they must be the same type or one
//     must be INT64 and the other UINT64).  NOT will be expressed as a $not
//     FunctionCall wrapping this SubqueryExpr.
//
// The subquery for a SCALAR or ARRAY or IN subquery must have exactly one
// output column.
// The output type for a SCALAR or ARRAY subquery is that column's type or
// an array of that column's type.  (The subquery scan may include a Project
// with a MakeStruct or MakeProto expression to construct a single value
// from multiple columns.)
message ResolvedSubqueryExprProto {
  optional ResolvedExprProto parent = 1;

  optional ResolvedSubqueryExprEnums.SubqueryType subquery_type = 2;
  repeated ResolvedColumnRefProto parameter_list = 3;
  // Field is only populated for subquery of type IN.
  optional AnyResolvedExprProto in_expr = 4;
  optional AnyResolvedScanProto subquery = 5;
  // Note: Hints currently happen only for EXISTS or IN subquery but
  // not for ARRAY or SCALAR subquery.
  repeated ResolvedOptionProto hint_list = 6;
}

// Common superclass for all Scans, which are nodes that produce rows
// (e.g. scans, joins, table subqueries).  A query's FROM clause is
// represented as a single Scan that composes all input sources into
// a single row stream.
//
// Each Scan has a <column_list> that says what columns are produced.
// The Scan logically produces a stream of output rows, where each row
// has exactly these columns.
//
// Each Scan may have an attached <hint_list>, storing each hint as
// a ResolvedOption.
//
// If <is_ordered> is true, this Scan produces an ordered output, either
// by generating order itself (OrderByScan) or by preserving the order
// of its single input scan (LimitOffsetScan, ProjectScan, or WithScan).
message AnyResolvedScanProto {
  oneof node {
    ResolvedSingleRowScanProto resolved_single_row_scan_node = 19;
    ResolvedTableScanProto resolved_table_scan_node = 20;
    ResolvedJoinScanProto resolved_join_scan_node = 21;
    ResolvedArrayScanProto resolved_array_scan_node = 22;
    ResolvedFilterScanProto resolved_filter_scan_node = 24;
    ResolvedSetOperationScanProto resolved_set_operation_scan_node = 26;
    ResolvedOrderByScanProto resolved_order_by_scan_node = 27;
    ResolvedLimitOffsetScanProto resolved_limit_offset_scan_node = 28;
    ResolvedWithRefScanProto resolved_with_ref_scan_node = 29;
    ResolvedAnalyticScanProto resolved_analytic_scan_node = 30;
    ResolvedSampleScanProto resolved_sample_scan_node = 31;
    ResolvedProjectScanProto resolved_project_scan_node = 35;
    ResolvedWithScanProto resolved_with_scan_node = 51;
    ResolvedTVFScanProto resolved_tvfscan_node = 81;
    ResolvedRelationArgumentScanProto resolved_relation_argument_scan_node = 89;
    AnyResolvedAggregateScanBaseProto resolved_aggregate_scan_base_node = 111;
  }
}

message ResolvedScanProto {
  optional ResolvedNodeProto parent = 1;

  repeated ResolvedColumnProto column_list = 2;
  repeated ResolvedOptionProto hint_list = 3;
  optional bool is_ordered = 4;
}

// Represents a machine learning model as a TVF argument.
// <model> is the machine learning model object known to the resolver
// (usually through the catalog).
message ResolvedModelProto {
  optional ResolvedArgumentProto parent = 1;

  optional ModelRefProto model = 2;
}

// Represents a connection object as a TVF argument.
// <connection> is the connection object encapsulated metadata to connect to
// an external data source.
message ResolvedConnectionProto {
  optional ResolvedArgumentProto parent = 1;

  optional ConnectionRefProto connection = 2;
}

// Scan that produces a single row with no columns.  Used for queries without
// a FROM clause, where all output comes from the select list.
message ResolvedSingleRowScanProto {
  optional ResolvedScanProto parent = 1;

}

// Scan a Table.
// The <column_list>[i] should be matched to a Table column by
// <table>.GetColumn(<column_index_list>[i]).
//
// If AnalyzerOptions::prune_unused_columns is true, the <column_list> and
// <column_index_list> will include only columns that were referenced
// in the user query. (SELECT * counts as referencing all columns.)
// This column_list can then be used for column-level ACL checking on tables.
//
// for_system_time_expr when non NULL resolves to TIMESTAMP used in
// FOR SYSTEM_TIME AS OF clause. The expression is expected to be constant
// and no columns are visible to it.
//
// If provided, <alias> refers to an explicit alias which was used to
// reference a Table in the user query. If the Table was given an implicitly
// generated alias, then defaults to "".
//
// TODO: Enforce <column_index_list> in the constructor arg list. For
// historical reasons, some clients match <column_list> to Table columns by
// name. All code building this should always set_column_index_list() to
// provide the indexes of all columns in <table> right after the construction
// of a ResolvedTableScan.
message ResolvedTableScanProto {
  optional ResolvedScanProto parent = 1;

  optional TableRefProto table = 2;
  optional AnyResolvedExprProto for_system_time_expr = 3;
  repeated int64 column_index_list = 4;
  optional string alias = 5;
}

// A Scan that joins two input scans.
// The <column_list> will contain columns selected from the union
// of the input scan's <column_lists>.
// When the join is a LEFT/RIGHT/FULL join, ResolvedColumns that came from
// the non-joined side get NULL values.
message ResolvedJoinScanProto {
  optional ResolvedScanProto parent = 1;

  optional ResolvedJoinScanEnums.JoinType join_type = 2;
  optional AnyResolvedScanProto left_scan = 3;
  optional AnyResolvedScanProto right_scan = 4;
  optional AnyResolvedExprProto join_expr = 5;
}

// Scan an array value, produced from some expression.
//
// If input_scan is NULL, this scans the given array value and produces
// one row per array element.  This can occur when using UNNEST(expression).
//
// If <input_scan> is non-NULL, for each row in the stream produced by
// input_scan, this evaluates the expression <array_expr> (which must return
// an array type) and then produces a stream with one row per array element.
//
// If <join_expr> is non-NULL, then this condition is evaluated as an ON
// clause for the array join.  The named column produced in <array_expr>
// may be used inside <join_expr>.
//
// If the array is empty (after evaluating <join_expr>), then
// 1. If <is_outer> is false, the scan produces zero rows.
// 2. If <is_outer> is true, the scan produces one row with a NULL value for
//    the <element_column>.
//
// <element_column> is the new column produced by this scan that stores the
// array element value for each row.
//
// If present, <array_offset_column> defines the column produced by this
// scan that stores the array offset (0-based) for the corresponding
// <element_column>.
//
// This node's column_list can have columns from input_scan, <element_column>
// and <array_offset_column>.
message ResolvedArrayScanProto {
  optional ResolvedScanProto parent = 1;

  optional AnyResolvedScanProto input_scan = 2;
  optional AnyResolvedExprProto array_expr = 3;
  optional ResolvedColumnProto element_column = 4;
  optional ResolvedColumnHolderProto array_offset_column = 5;
  optional AnyResolvedExprProto join_expr = 6;
  optional bool is_outer = 7;
}

// This wrapper is used for an optional ResolvedColumn inside another node.
message ResolvedColumnHolderProto {
  optional ResolvedArgumentProto parent = 1;

  optional ResolvedColumnProto column = 2;
}

// Scan rows from input_scan, and emit all rows where filter_expr
// evaluates to true.  filter_expr is always of type bool.
// This node's column_list will be a subset of input_scan's column_list.
message ResolvedFilterScanProto {
  optional ResolvedScanProto parent = 1;

  optional AnyResolvedScanProto input_scan = 2;
  optional AnyResolvedExprProto filter_expr = 3;
}

// List of group by columns that form a grouping set.
//
// Columns must come from group_by_list in ResolvedAggregateScan.
// group_by_column_list will not contain any duplicates. There may be more
// than one ResolvedGroupingSet in the ResolvedAggregateScan with the same
// columns, however.
message ResolvedGroupingSetProto {
  optional ResolvedArgumentProto parent = 1;

  repeated ResolvedColumnRefProto group_by_column_list = 2;
}

// Base class for aggregation scans. Apply aggregation to rows produced from
// input_scan, and output aggregated rows.
//
// Group by keys in <group_by_list>.  If <group_by_list> is empty,
// aggregate all input rows into one output row.
//
// Compute all aggregations in <aggregate_list>.  All expressions in
// <aggregate_list> have a ResolvedAggregateFunctionCall with mode
// Function::AGGREGATE as their outermost node.
//
// The output <column_list> contains only columns produced from
// <group_by_list> and <aggregate_list>.  No other columns are visible after
// aggregation.
message AnyResolvedAggregateScanBaseProto {
  oneof node {
    ResolvedAggregateScanProto resolved_aggregate_scan_node = 25;
  }
}

message ResolvedAggregateScanBaseProto {
  optional ResolvedScanProto parent = 1;

  optional AnyResolvedScanProto input_scan = 2;
  repeated ResolvedComputedColumnProto group_by_list = 3;
  repeated ResolvedComputedColumnProto aggregate_list = 4;
}

// Apply aggregation to rows produced from input_scan, and output aggregated
// rows.
//
// For each item in <grouping_set_list>, output additional rows computing the
// same <aggregate_list> over the input rows using a particular grouping set.
// The aggregation input values, including <input_scan>, computed columns in
// <group_by_list>, and aggregate function arguments in <aggregate_list>,
// should be computed just once and then reused as aggregation input for each
// grouping set. (This ensures that ROLLUP rows have correct totals, even
// with non-stable functions in the input.) For each grouping set, the
// <group_by_list> elements not included in the <group_by_column_list> are
// replaced with NULL.
//
// <rollup_column_list> is the original list of columns from
// GROUP BY ROLLUP(...), if there was a ROLLUP clause, and is used only for
// rebuilding equivalent SQL for the resolved AST. Engines should refer to
// <grouping_set_list> rather than <rollup_column_list>.
message ResolvedAggregateScanProto {
  optional ResolvedAggregateScanBaseProto parent = 1;

  repeated ResolvedGroupingSetProto grouping_set_list = 5;
  repeated ResolvedColumnRefProto rollup_column_list = 6;
}

// This is one input item in a ResolvedSetOperation.
// The <output_column_list> matches 1:1 with the ResolvedSetOperation's
// <column_list> and specifies how columns from <scan> map to output columns.
// Each column from <scan> can map to zero or more output columns.
message ResolvedSetOperationItemProto {
  optional ResolvedArgumentProto parent = 1;

  optional AnyResolvedScanProto scan = 2;
  repeated ResolvedColumnProto output_column_list = 3;
}

// Apply a set operation (specified by <op_type>) on two or more input scans.
//
// <scan_list> will have at least two elements.
//
// <column_list> is a set of new ResolvedColumns created by this scan.
// Each input ResolvedSetOperationItem has an <output_column_list> which
// matches 1:1 with <column_list> and specifies how the input <scan>'s
// columns map into the final <column_list>.
//
// - Results of {UNION, INTERSECT, EXCEPT} ALL can include duplicate rows.
//   More precisely, with two input scans, if a given row R appears exactly
//   m times in first input and n times in second input (m >= 0, n >= 0):
//   For UNION ALL, R will appear exactly m + n times in the result.
//   For INTERSECT ALL, R will appear exactly min(m, n) in the result.
//   For EXCEPT ALL, R will appear exactly max(m - n, 0) in the result.
//
// - Results of {UNION, INTERSECT, EXCEPT} DISTINCT cannot contain any
//   duplicate rows. For UNION and INTERSECT, the DISTINCT is computed
//   after the result above is computed.  For EXCEPT DISTINCT, row R will
//   appear once in the output if m > 0 and n = 0.
//
// - For n (>2) input scans, the above operations generalize so the output is
//   the same as if the inputs were combined incrementally from left to right.
message ResolvedSetOperationScanProto {
  optional ResolvedScanProto parent = 1;

  optional ResolvedSetOperationScanEnums.SetOperationType op_type = 2;
  repeated ResolvedSetOperationItemProto input_item_list = 4;
}

// Apply ordering to rows produced from input_scan, and output ordered
// rows.
//
// The <order_by_item_list> must not be empty.  Each element identifies
// a sort column and indicates direction (ascending or descending).
//
// Order Preservation:
//   A ResolvedScan produces an ordered output if it has <is_ordered>=true.
//   If <is_ordered>=false, the scan may discard order.  This can happen
//   even for a ResolvedOrderByScan, if it is the top-level scan in a
//   subquery (which discards order).
//
// The following Scan nodes may have <is_ordered>=true, producing or
// propagating an ordering:
//   * ResolvedOrderByScan
//   * ResolvedLimitOffsetScan
//   * ResolvedProjectScan
//   * ResolvedWithScan
// Other Scan nodes will always discard ordering.
message ResolvedOrderByScanProto {
  optional ResolvedScanProto parent = 1;

  optional AnyResolvedScanProto input_scan = 2;
  repeated ResolvedOrderByItemProto order_by_item_list = 3;
}

// Apply a LIMIT and optional OFFSET to the rows from input_scan. Emit all
// rows after OFFSET rows have been scanned and up to LIMIT total rows
// emitted. The offset is the number of rows to skip.
// E.g., OFFSET 1 means to skip one row, so the first row emitted will be the
// second ROW, provided the LIMIT is greater than zero.
//
// The arguments to LIMIT <int64> OFFSET <int64> must be non-negative
// integer literals or (possibly casted) query parameters.  Query
// parameter values must be checked at run-time by ZetaSQL compliant
// backend systems.
//
// OFFSET is optional and the absence of OFFSET implies OFFSET 0.
message ResolvedLimitOffsetScanProto {
  optional ResolvedScanProto parent = 1;

  optional AnyResolvedScanProto input_scan = 2;
  optional AnyResolvedExprProto limit = 3;
  optional AnyResolvedExprProto offset = 4;
}

// Scan the subquery defined in a WITH statement.
// See ResolvedWithScan for more detail.
// The column_list produced here will match 1:1 with the column_list produced
// by the referenced subquery and will given a new unique name to each
// column produced for this scan.
message ResolvedWithRefScanProto {
  optional ResolvedScanProto parent = 1;

  optional string with_query_name = 2;
}

// Apply analytic functions to rows produced from input_scan.
//
// The set of analytic functions are partitioned into a list of analytic
// function groups <function_group_list> by the window PARTITION BY and the
// window ORDER BY.
//
// The output <column_list> contains all columns from <input_scan>,
// one column per analytic function. It may also conain partitioning/ordering
// expression columns if they reference to select columns.
message ResolvedAnalyticScanProto {
  optional ResolvedScanProto parent = 1;

  optional AnyResolvedScanProto input_scan = 2;
  repeated ResolvedAnalyticFunctionGroupProto function_group_list = 3;
}

// Samples rows from <input_scan>.
// Specs: (broken link)
// Specs for WITH WEIGHT and PARTITION BY: (broken link)
//
// <method> is the identifier for the sampling algorithm and will always be
// in lowercase.
// For example BERNOULLI, RESERVOIR, SYSTEM. Engines can also support their
// own implementation-specific set of sampling algorithms.
//
// <size> and <unit> specifies the sample size.
// If <unit> is "ROWS", <size> must be an <int64> and non-negative.
// If <unit> is "PERCENT", <size> must either be a <double> or an <int64> and
// in the range [0, 100].
// <size> can only be a literal value or a (possibly casted) parameter.
//
// <repeatable_argument> is present if we had a REPEATABLE(<argument>) in the
// TABLESAMPLE clause and can only be a literal value or a (possibly
// casted) parameter.
//
// If present, <weight_column> defines the column produced by this scan that
// stores the scaling weight for the corresponding sampled row.
//
// <partition_by_list> can be empty. If <partition_by_list> is not empty,
// <unit> must be ROWS and <method> must be RESERVOIR.
message ResolvedSampleScanProto {
  optional ResolvedScanProto parent = 1;

  optional AnyResolvedScanProto input_scan = 2;
  optional string method = 3;
  optional AnyResolvedExprProto size = 4;
  optional ResolvedSampleScanEnums.SampleUnit unit = 5;
  optional AnyResolvedExprProto repeatable_argument = 6;
  optional ResolvedColumnHolderProto weight_column = 7;
  repeated AnyResolvedExprProto partition_by_list = 8;
}

// This is used when an expression is computed and given a name (a new
// ResolvedColumn) that can be referenced elsewhere.  The new ResolvedColumn
// can appear in a column_list or in ResolvedColumnRefs in other expressions,
// when appropriate.  This node is not an expression itself - it is a
// container that holds an expression.
message ResolvedComputedColumnProto {
  optional ResolvedArgumentProto parent = 1;

  optional ResolvedColumnProto column = 2;
  optional AnyResolvedExprProto expr = 3;
}

// This represents one column of an ORDER BY clause, with the requested
// ordering direction.
//
// <collation_name> indicates the COLLATE specific rules of ordering.
// If non-NULL, must be a string literal or a string parameter.
// See (broken link).
//
// <null_order> indicates the ordering of NULL values relative to non-NULL
// values. NULLS_FIRST indicates that NULLS sort prior to non-NULL values,
// and NULLS_LAST indicates that NULLS sort after non-NULL values.
message ResolvedOrderByItemProto {
  optional ResolvedArgumentProto parent = 1;

  optional ResolvedColumnRefProto column_ref = 2;
  optional AnyResolvedExprProto collation_name = 3;
  optional bool is_descending = 4;
  optional ResolvedOrderByItemEnums.NullOrderMode null_order = 5;
}

// This is used in CREATE TABLE statements to provide column annotations
// such as NOT NULL and OPTIONS().
//
// This class is recursive. It mirrors the structure of the column type
// except that child_list might be truncated.
//
// For ARRAY:
//   If the element or its subfield has annotations, then child_list.size()
//   is 1, and child_list(0) stores the element annotations.
//   Otherwise child_list is empty.
// For STRUCT:
//   If the i-th field has annotations then child_list(i) stores the
//   field annotations.
//   Otherwise either child_list.size() <= i or child_list(i) is trivial.
//   If none of the fields and none of their subfields has annotations, then
//   child_list is empty.
// For other types, child_list is empty.
message ResolvedColumnAnnotationsProto {
  optional ResolvedArgumentProto parent = 1;

  optional bool not_null = 2;
  repeated ResolvedOptionProto option_list = 3;
  repeated ResolvedColumnAnnotationsProto child_list = 4;
}

// <expression> indicates the expression that defines the column. The type of
// the expression will always match the type of the column.
//   - The <expression> can contain ResolvedColumnRefs corresponding to
//   ResolvedColumnDefinition.<column> for any of the
//   ResolvedColumnDefinitions in the enclosing statement.
//   - The expression can never include a subquery.
//
// <is_stored> indicates whether the value of the expression should be
// pre-emptively computed to save work at read time. When is_stored is true,
// <expression> cannot contain a volatile function (e.g. RAND).
//
// <is_on_write> indicates that the value of this column should be calculated
// at write time. As opposed to <is_stored> the <expression> can contain
// volatile functions (e.g. RAND).
//
// Only one of <is_stored> or <is_on_write> can be true.
//
// See (broken link).
message ResolvedGeneratedColumnInfoProto {
  optional ResolvedArgumentProto parent = 1;

  optional AnyResolvedExprProto expression = 2;
  optional bool is_stored = 3;
  optional bool is_on_write = 4;
}

// This is used in CREATE TABLE statements to provide an explicit column
// definition.
//
// if <is_hidden> is TRUE, then the column won't show up in SELECT * queries.
//
// if <generated_column_info> is non-NULL, then this table column is a
// generated column.
//
// <column> defines an ID for the column, which may appear in expressions in
// the PARTITION BY, CLUSTER BY clause or <generated_column_info> if either
// is present.
message ResolvedColumnDefinitionProto {
  optional ResolvedArgumentProto parent = 1;

  optional string name = 2;
  optional TypeProto type = 3;
  optional ResolvedColumnAnnotationsProto annotations = 4;
  optional bool is_hidden = 5;
  optional ResolvedColumnProto column = 6;
  optional ResolvedGeneratedColumnInfoProto generated_column_info = 7;
}

// This represents the PRIMARY KEY constraint on a table.
// <column_offset_list> provides the offsets of the column definitions that
//                      comprise the primary key. This is empty when a
//                      0-element primary key is defined.
message ResolvedPrimaryKeyProto {
  optional ResolvedArgumentProto parent = 1;

  repeated int64 column_offset_list = 2;
  repeated ResolvedOptionProto option_list = 3;
}

// This represents the FOREIGN KEY constraint on a table. It is of the form:
//
//   CONSTRAINT <constraint_name>
//   FOREIGN KEY <referencing_column_offset_list>
//   REFERENCES <referenced_table> <referenced_column_offset_list>
//   <match_mode>
//   <update_action>
//   <delete_action>
//   <enforced>
//   <option_list>
//
// <constraint_name> uniquely identifies the constraint.
//
// <referencing_column_offset_list> provides the offsets of the column
// definitions for the table defining the foreign key.
//
// <referenced_table> identifies the table this constraint references.
//
// <referenced_column_offset_list> provides the offsets of the column
// definitions for the table referenced by the foreign key.
//
// <match_mode> specifies how referencing keys with null values are handled.
//
// <update_action> specifies what action to take, if any, when a referenced
// value is updated.
//
// <delete_action> specifies what action to take, if any, when a row with a
// referenced values is deleted.
//
// <enforced> specifies whether or not the constraint is enforced.
//
// <option_list> for foreign key table constraints. Empty for foreign key
// column attributes (see instead ResolvedColumnAnnotations).
message ResolvedForeignKeyProto {
  optional ResolvedArgumentProto parent = 1;

  optional string constraint_name = 2;
  repeated int64 referencing_column_offset_list = 3;
  optional TableRefProto referenced_table = 4;
  repeated int64 referenced_column_offset_list = 5;
  optional ResolvedForeignKeyEnums.MatchMode match_mode = 6;
  optional ResolvedForeignKeyEnums.ActionOperation update_action = 7;
  optional ResolvedForeignKeyEnums.ActionOperation delete_action = 8;
  optional bool enforced = 9;
  repeated ResolvedOptionProto option_list = 10;
}

// This represents the CHECK constraint on a table. It is of the form:
//
//   CONSTRAINT <constraint_name>
//   CHECK <expression>
//   <enforced>
//   <option_list>
//
// <constraint_name> uniquely identifies the constraint.
//
// <expression> defines a boolean expression to be evaluated when the row is
// updated. If the result is FALSE, update to the row is not allowed.
//
// <enforced> specifies whether or not the constraint is enforced.
//
// <option_list> list of options for check constraint.
//
// See (broken link).
message ResolvedCheckConstraintProto {
  optional ResolvedArgumentProto parent = 1;

  optional string constraint_name = 2;
  optional AnyResolvedExprProto expression = 3;
  optional bool enforced = 4;
  repeated ResolvedOptionProto option_list = 5;
}

// This is used in ResolvedQueryStmt to provide a user-visible name
// for each output column.
message ResolvedOutputColumnProto {
  optional ResolvedArgumentProto parent = 1;

  optional string name = 2;
  optional ResolvedColumnProto column = 3;
}

// A Project node computes new expression values, and possibly drops
// columns from the input Scan's column_list.
//
// Each entry in <expr_list> is a new column computed from an expression.
//
// The column_list can include any columns from input_scan, plus these
// newly computed columns.
//
// NOTE: This scan will propagate the is_ordered property of <input_scan>
// by default.  To make this scan unordered, call set_is_ordered(false).
message ResolvedProjectScanProto {
  optional ResolvedScanProto parent = 1;

  repeated ResolvedComputedColumnProto expr_list = 2;
  optional AnyResolvedScanProto input_scan = 3;
}

// This scan represents a call to a table-valued function (TVF). Each TVF
// returns an entire output relation instead of a single scalar value. The
// enclosing query may refer to the TVF as if it were a table subquery. The
// TVF may accept scalar arguments and/or other input relations.
//
// Scalar arguments work the same way as arguments for non-table-valued
// functions: in the resolved AST, their types are equal to the required
// argument types specified in the function signature.
//
// The function signature may also include relation arguments, and any such
// relation argument may specify a required schema. If such a required schema
// is present, then in the resolved AST, the ResolvedScan for each relational
// ResolvedTVFArgument is guaranteed to have the same number of columns as
// the required schema, and the provided columns match position-wise with the
// required columns. Each provided column has the same name and type as the
// corresponding required column.
//
// <column_list> is a set of new ResolvedColumns created by this scan.
// These output columns match positionally with the columns in the output
// schema of <signature>.
//
// <tvf> The TableValuedFunction entry that the catalog returned for this TVF
//       scan. Contains non-concrete function signatures which may include
//       arguments with templated types.
// <signature> The concrete table function signature for this TVF call,
//             including the types of all scalar arguments and the
//             number and types of columns of all table-valued
//             arguments. An engine may also subclass this object to
//             provide extra custom information and return an instance
//             of the subclass from the TableValuedFunction::Resolve
//             method.
// <argument_list> The vector of resolved arguments for this TVF call.
// <alias> The AS alias for the scan, or empty if none.
message ResolvedTVFScanProto {
  optional ResolvedScanProto parent = 1;

  optional TableValuedFunctionRefProto tvf = 2;
  optional TVFSignatureProto signature = 3;
  repeated ResolvedTVFArgumentProto argument_list = 5;
  optional string alias = 6;
}

// This represents an argument to a table-valued function (TVF). The argument
// can be semantically scalar, relational, represent a model or a connection.
// Only one of the four fields will be set.
//
// <expr> The expression representing a scalar TVF argument.
// <scan> The scan representing a relational TVF argument.
// <model> The model representing an ML model TVF argument.
// <connection> The connection representing a connection object TVF argument.
//
// <argument_column_list> maps columns from <scan> into specific columns
// of the TVF argument's input schema, matching those columns positionally.
// i.e. <scan>'s column_list may have fewer columns or out-of-order columns,
// and this vector maps those columns into specific TVF input columns.
message ResolvedTVFArgumentProto {
  optional ResolvedArgumentProto parent = 1;

  optional AnyResolvedExprProto expr = 2;
  optional AnyResolvedScanProto scan = 3;
  optional ResolvedModelProto model = 5;
  optional ResolvedConnectionProto connection = 6;
  repeated ResolvedColumnProto argument_column_list = 4;
}

// The superclass of all ZetaSQL statements.
message AnyResolvedStatementProto {
  oneof node {
    ResolvedExplainStmtProto resolved_explain_stmt_node = 37;
    ResolvedQueryStmtProto resolved_query_stmt_node = 38;
    AnyResolvedCreateStatementProto resolved_create_statement_node = 39;
    ResolvedExportDataStmtProto resolved_export_data_stmt_node = 43;
    ResolvedDefineTableStmtProto resolved_define_table_stmt_node = 44;
    ResolvedDescribeStmtProto resolved_describe_stmt_node = 45;
    ResolvedShowStmtProto resolved_show_stmt_node = 46;
    ResolvedBeginStmtProto resolved_begin_stmt_node = 47;
    ResolvedCommitStmtProto resolved_commit_stmt_node = 48;
    ResolvedRollbackStmtProto resolved_rollback_stmt_node = 49;
    ResolvedDropStmtProto resolved_drop_stmt_node = 50;
    ResolvedInsertStmtProto resolved_insert_stmt_node = 63;
    ResolvedDeleteStmtProto resolved_delete_stmt_node = 64;
    ResolvedUpdateStmtProto resolved_update_stmt_node = 66;
    AnyResolvedGrantOrRevokeStmtProto resolved_grant_or_revoke_stmt_node = 68;
    ResolvedAlterTableSetOptionsStmtProto resolved_alter_table_set_options_stmt_node = 71;
    ResolvedRenameStmtProto resolved_rename_stmt_node = 72;
    ResolvedCreateRowAccessPolicyStmtProto resolved_create_row_access_policy_stmt_node = 73;
    ResolvedDropRowAccessPolicyStmtProto resolved_drop_row_access_policy_stmt_node = 74;
    ResolvedDropFunctionStmtProto resolved_drop_function_stmt_node = 80;
    ResolvedCallStmtProto resolved_call_stmt_node = 83;
    ResolvedImportStmtProto resolved_import_stmt_node = 86;
    ResolvedModuleStmtProto resolved_module_stmt_node = 87;
    ResolvedCreateDatabaseStmtProto resolved_create_database_stmt_node = 95;
    ResolvedAssertStmtProto resolved_assert_stmt_node = 98;
    ResolvedMergeStmtProto resolved_merge_stmt_node = 101;
    AnyResolvedAlterObjectStmtProto resolved_alter_object_stmt_node = 114;
    ResolvedSetTransactionStmtProto resolved_set_transaction_stmt_node = 120;
    ResolvedDropMaterializedViewStmtProto resolved_drop_materialized_view_stmt_node = 121;
    ResolvedStartBatchStmtProto resolved_start_batch_stmt_node = 122;
    ResolvedRunBatchStmtProto resolved_run_batch_stmt_node = 123;
    ResolvedAbortBatchStmtProto resolved_abort_batch_stmt_node = 124;
    ResolvedTruncateStmtProto resolved_truncate_stmt_node = 133;
    ResolvedExecuteImmediateStmtProto resolved_execute_immediate_stmt_node = 140;
    ResolvedAssignmentStmtProto resolved_assignment_stmt_node = 142;
  }
}

message ResolvedStatementProto {
  optional ResolvedNodeProto parent = 1;

  repeated ResolvedOptionProto hint_list = 2;
}

// An Explain statement. This is always the root of a statement hierarchy.
// Its child may be any statement type except another ResolvedExplainStmt.
//
// It is implementation dependent what action a back end system takes for an
// ExplainStatement.
message ResolvedExplainStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional AnyResolvedStatementProto statement = 2;
}

// A SQL query statement.  This is the outermost query statement that runs
// and produces rows of output, like a SELECT.  (The contained query may be
// a Scan corresponding to a non-Select top-level operation like UNION ALL
// or WITH.)
//
// <output_column_list> gives the user-visible column names that should be
// returned in the API or query tools.  There may be duplicate names, and
// multiple output columns may reference the same column from <query>.
message ResolvedQueryStmtProto {
  optional ResolvedStatementProto parent = 1;

  repeated ResolvedOutputColumnProto output_column_list = 2;
  // If true, the result of this query is a value table. Rather than
  // producing rows with named columns, it produces rows with a single
  // unnamed value type.  output_column_list will have exactly one
  // column, with an empty name. See (broken link).
  optional bool is_value_table = 3;
  optional AnyResolvedScanProto query = 4;
}

// This statement:
//   CREATE DATABASE <name> [OPTIONS (...)]
// <name_path> is a vector giving the identifier path in the database name.
// <option_list> specifies the options of the database.
message ResolvedCreateDatabaseStmtProto {
  optional ResolvedStatementProto parent = 1;

  repeated string name_path = 2;
  repeated ResolvedOptionProto option_list = 3;
}

// Common superclass for CREATE statements with standard modifiers like
//         CREATE [OR REPLACE] [TEMP|TEMPORARY|PUBLIC|PRIVATE] <object type>
//         [IF NOT EXISTS] <name> ...
//
// <name_path> is a vector giving the identifier path in the table name.
// <create_scope> is the relevant scope, i.e., DEFAULT, TEMP, PUBLIC,
//                or PRIVATE.  PUBLIC/PRIVATE are only valid in module
//                resolution context, see (broken link)
//                for details.
// <create_mode> indicates if this was CREATE, CREATE OR REPLACE, or
//               CREATE IF NOT EXISTS.
message AnyResolvedCreateStatementProto {
  oneof node {
    ResolvedCreateFunctionStmtProto resolved_create_function_stmt_node = 76;
    ResolvedCreateTableFunctionStmtProto resolved_create_table_function_stmt_node = 88;
    ResolvedCreateIndexStmtProto resolved_create_index_stmt_node = 97;
    ResolvedCreateConstantStmtProto resolved_create_constant_stmt_node = 99;
    AnyResolvedCreateTableStmtBaseProto resolved_create_table_stmt_base_node = 106;
    ResolvedCreateModelStmtProto resolved_create_model_stmt_node = 107;
    AnyResolvedCreateViewBaseProto resolved_create_view_base_node = 108;
    ResolvedCreateProcedureStmtProto resolved_create_procedure_stmt_node = 125;
  }
}

message ResolvedCreateStatementProto {
  optional ResolvedStatementProto parent = 1;

  repeated string name_path = 2;
  optional ResolvedCreateStatementEnums.CreateScope create_scope = 5;
  optional ResolvedCreateStatementEnums.CreateMode create_mode = 4;
}

// Represents one of indexed items in CREATE INDEX statement, with the
// ordering direction specified.
message ResolvedIndexItemProto {
  optional ResolvedArgumentProto parent = 1;

  optional ResolvedColumnRefProto column_ref = 2;
  optional bool descending = 3;
}

// This is used in CREATE INDEX STMT to represent the unnest operation
// performed on the base table. The produced element columns or array offset
// columns (optional) can appear in other ResolvedUnnestItem or index keys.
//
// <array_expr> is the expression of the array field, e.g., t.array_field.
// <element_column> is the new column produced by this unnest item that
//                  stores the array element value for each row.
// <array_offset_column> is optional. If present, it defines the column
//                       produced by this unnest item that stores the array
//                       offset (0-based) for the corresponding
//                       <element_column>.
message ResolvedUnnestItemProto {
  optional ResolvedArgumentProto parent = 1;

  optional AnyResolvedExprProto array_expr = 2;
  optional ResolvedColumnProto element_column = 3;
  optional ResolvedColumnHolderProto array_offset_column = 4;
}

// This statement:
// CREATE [OR REPLACE] [UNIQUE] INDEX [IF NOT EXISTS] <index_name_path>
// ON <table_name_path>
// [STORING (Expression, ...)]
// [UNNEST(path_expression) [[AS] alias] [WITH OFFSET [[AS] alias]], ...]
// (path_expression [ASC|DESC], ...) [OPTIONS (name=value, ...)];
//
// <table_name_path> is the name of table being indexed.
// <table_scan> is a TableScan on the table being indexed.
// <is_unique> specifies if the index has unique entries.
// <index_item_list> has the columns being indexed, specified as references
//                   to 'computed_columns_list' entries or the columns of
//                   'table_scan'.
// <storing_expression_list> has the expressions in the storing clause.
// <option_list> has engine-specific directives for how and where to
//               materialize this index.
// <computed_columns_list> has computed columns derived from the columns of
//                         'table_scan' or 'unnest_expressions_list'. For
//                         example, the extracted field (e.g., x.y.z).
// <unnest_expressions_list> has unnest expressions derived from
//                           'table_scan' or previous unnest expressions in
//                           the list. So the list order is significant.
message ResolvedCreateIndexStmtProto {
  optional ResolvedCreateStatementProto parent = 1;

  repeated string table_name_path = 2;
  optional ResolvedTableScanProto table_scan = 3;
  optional bool is_unique = 4;
  repeated ResolvedIndexItemProto index_item_list = 5;
  repeated AnyResolvedExprProto storing_expression_list = 9;
  repeated ResolvedOptionProto option_list = 6;
  repeated ResolvedComputedColumnProto computed_columns_list = 7;
  repeated ResolvedUnnestItemProto unnest_expressions_list = 8;
}

// This statement:
//   CREATE [TEMP] TABLE <name> (column type, ...)
//   [PARTITION BY expr, ...] [CLUSTER BY expr, ...]
//   [OPTIONS (...)]
//
// <option_list> has engine-specific directives for how and where to
//               materialize this table.
// <column_definition_list> has the names and types of the columns in the
//                          created table. If <is_value_table> is true, it
//                          must contain exactly one column, with a generated
//                          name such as "$struct".
// <pseudo_column_list> is a list of some pseudo-columns expected to be
//                      present on the created table (provided by
//                      AnalyzerOptions::SetDdlPseudoColumns*).  These can be
//                      referenced in expressions in <partition_by_list> and
//                      <cluster_by_list>.
// <primary_key> specifies the PRIMARY KEY constraint on the table, it is
//               nullptr when no PRIMARY KEY is specified.
// <foreign_key_list> specifies the FOREIGN KEY constraints on the table.
// <check_constraint_list> specifies the CHECK constraints on the table.
// <partition_by_list> specifies the partitioning expressions for the table.
// <cluster_by_list> specifies the clustering expressions for the table.
// <is_value_table> specifies whether the table is a value table.
//                  See (broken link).
message AnyResolvedCreateTableStmtBaseProto {
  oneof node {
    ResolvedCreateTableAsSelectStmtProto resolved_create_table_as_select_stmt_node = 40;
    ResolvedCreateExternalTableStmtProto resolved_create_external_table_stmt_node = 42;
    ResolvedCreateTableStmtProto resolved_create_table_stmt_node = 90;
  }
}

message ResolvedCreateTableStmtBaseProto {
  optional ResolvedCreateStatementProto parent = 1;

  repeated ResolvedOptionProto option_list = 2;
  repeated ResolvedColumnDefinitionProto column_definition_list = 3;
  repeated ResolvedColumnProto pseudo_column_list = 7;
  optional ResolvedPrimaryKeyProto primary_key = 4;
  repeated ResolvedForeignKeyProto foreign_key_list = 9;
  repeated ResolvedCheckConstraintProto check_constraint_list = 10;
  repeated AnyResolvedExprProto partition_by_list = 5;
  repeated AnyResolvedExprProto cluster_by_list = 6;
  optional bool is_value_table = 8;
}

// This statement:
// CREATE [TEMP] TABLE <name> (column schema, ...)
// [PARTITION BY expr, ...] [CLUSTER BY expr, ...]
// [OPTIONS (...)]
message ResolvedCreateTableStmtProto {
  optional ResolvedCreateTableStmtBaseProto parent = 1;

}

// This statement:
//   CREATE [TEMP] TABLE <name> [(column schema, ...)]
//   [PARTITION BY expr, ...] [CLUSTER BY expr, ...] [OPTIONS (...)]
//   AS SELECT ...
//
// The <output_column_list> matches 1:1 with the <column_definition_list> in
// ResolvedCreateTableStmtBase, and maps ResolvedColumns produced by <query>
// into specific columns of the created table.  The output column names and
// types must match the column definition names and types.  If the table is
// a value table, <output_column_list> must have exactly one column, with a
// generated name such as "$struct".
//
// <output_column_list> does not contain all table schema information that
// <column_definition_list> does. For example, NOT NULL annotations, column
// OPTIONS, and primary keys are only available in <column_definition_list>.
// Consumers are encouraged to read from <column_definition_list> rather
// than than <output_column_list> to determine the table schema, if possible.
//
// <query> is the query to run.
message ResolvedCreateTableAsSelectStmtProto {
  optional ResolvedCreateTableStmtBaseProto parent = 1;

  repeated ResolvedOutputColumnProto output_column_list = 2;
  optional AnyResolvedScanProto query = 3;
}

// This statement:
//   CREATE [TEMP] MODEL <name> [TRANSFORM(...)] [OPTIONS (...)] AS SELECT ..
//
// <option_list> has engine-specific directives for how to train this model.
// <output_column_list> matches 1:1 with the <query>'s column_list and the
//                      <column_definition_list>, and identifies the names
//                      and types of the columns output from the select
//                      statement.
// <query> is the select statement.
// <transform_input_column_list> introduces new ResolvedColumns that have the
//   same names and types of the columns in the <output_column_list>. The
//   transform expressions resolve against these ResolvedColumns. It's only
//   set when <transform_list> is non-empty.
// <transform_list> is the list of ResolvedComputedColumn in TRANSFORM
//   clause.
// <transform_output_column_list> matches 1:1 with <transform_list> output.
//   It records the names of the output columns from TRANSFORM clause.
// <transform_analytic_function_group_list> is the list of
//   AnalyticFunctionGroup for analytic functions inside TRANSFORM clause.
//   It records the input expression of the analytic functions. It can
//   see all the columns from <transform_input_column_list>. The only valid
//   group is for the full, unbounded window generated from empty OVER()
//   clause.
//   For example, CREATE MODEL statement
//   "create model Z
//     transform (max(c) over() as d)
//     options ()
//     as select 1 c, 2 b;"
//   will generate transform_analytic_function_group_list:
//   +-transform_analytic_function_group_list=
//     +-AnalyticFunctionGroup
//       +-analytic_function_list=
//         +-d#5 :=
//           +-AnalyticFunctionCall(ZetaSQL:max(INT64) -> INT64)
//             +-ColumnRef(type=INT64, column=Z.c#3)
//             +-window_frame=
//               +-WindowFrame(frame_unit=ROWS)
//                 +-start_expr=
//                 | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
//                 +-end_expr=
//                   +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
message ResolvedCreateModelStmtProto {
  optional ResolvedCreateStatementProto parent = 1;

  repeated ResolvedOptionProto option_list = 2;
  repeated ResolvedOutputColumnProto output_column_list = 3;
  optional AnyResolvedScanProto query = 4;
  repeated ResolvedColumnDefinitionProto transform_input_column_list = 8;
  repeated ResolvedComputedColumnProto transform_list = 5;
  repeated ResolvedOutputColumnProto transform_output_column_list = 6;
  repeated ResolvedAnalyticFunctionGroupProto transform_analytic_function_group_list = 7;
}

// Common superclass for CREATE view/materialized view:
//   CREATE [TEMP|MATERIALIZED] VIEW <name> [OPTIONS (...)] AS SELECT ...
//
// <option_list> has engine-specific directives for options attached to
//               this view.
// <output_column_list> has the names and types of the columns in the
//                      created view, and maps from <query>'s column_list
//                      to these output columns.
// <query> is the query to run.
// <sql> is the view query text.
// <sql_security> is the declared security mode for the function. Values
//        include 'INVOKER', 'DEFINER'.
//
// Note that <query> and <sql> are both marked as IGNORABLE because
// an engine could look at either one (but might not look at both).
// An engine must look at one (and cannot ignore both) to be
// semantically valid, but there is currently no way to enforce that.
//
// The view must produce named columns with unique names.
message AnyResolvedCreateViewBaseProto {
  oneof node {
    ResolvedCreateViewStmtProto resolved_create_view_stmt_node = 41;
    ResolvedCreateMaterializedViewStmtProto resolved_create_materialized_view_stmt_node = 119;
  }
}

message ResolvedCreateViewBaseProto {
  optional ResolvedCreateStatementProto parent = 1;

  repeated ResolvedOptionProto option_list = 2;
  repeated ResolvedOutputColumnProto output_column_list = 3;
  optional AnyResolvedScanProto query = 5;
  optional string sql = 6;
  optional ResolvedCreateStatementEnums.SqlSecurity sql_security = 7;
  // If true, this view produces a value table. Rather than producing
  // rows with named columns, it produces rows with a single unnamed
  // value type.  output_column_list will have exactly one column, with
  // an empty name. See (broken link).
  optional bool is_value_table = 4;
}

// This statement:
// CREATE [TEMP] VIEW <name> [OPTIONS (...)] AS SELECT ...
message ResolvedCreateViewStmtProto {
  optional ResolvedCreateViewBaseProto parent = 1;

}

// This statement:
// CREATE [TEMP] EXTERNAL TABLE <name> [(column type, ...)]
// [PARTITION BY expr, ...] [CLUSTER BY expr, ...] OPTIONS (...)
message ResolvedCreateExternalTableStmtProto {
  optional ResolvedCreateTableStmtBaseProto parent = 1;

}

// This statement:
//   EXPORT DATA [WITH CONNECTION] <connection> (<option_list>) AS SELECT ...
// which is used to run a query and export its result somewhere
// without giving the result a table name.
// <connection> connection reference for accessing destination source.
// <option_list> has engine-specific directives for how and where to
//               materialize the query result.
// <output_column_list> has the names and types of the columns produced by
//                      the query, and maps from <query>'s column_list
//                      to these output columns.  The engine may ignore
//                      the column names depending on the output format.
// <query> is the query to run.
//
// The query must produce named columns with unique names.
message ResolvedExportDataStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional ResolvedConnectionProto connection = 6;
  repeated ResolvedOptionProto option_list = 2;
  repeated ResolvedOutputColumnProto output_column_list = 3;
  // If true, the result of this query is a value table. Rather than
  // producing rows with named columns, it produces rows with a single
  // unnamed value type.  output_column_list will have exactly one
  // column, with an empty name. See (broken link).
  optional bool is_value_table = 4;
  optional AnyResolvedScanProto query = 5;
}

// This statement: DEFINE TABLE name (...);
//
// <name_path> is a vector giving the identifier path in the table name.
// <option_list> has engine-specific options of how the table is defined.
//
// DEFINE TABLE normally has the same effect as CREATE TEMP EXTERNAL TABLE.
message ResolvedDefineTableStmtProto {
  optional ResolvedStatementProto parent = 1;

  repeated string name_path = 2;
  repeated ResolvedOptionProto option_list = 3;
}

// This statement: DESCRIBE [<object_type>] <name> [FROM <from_name_path>];
//
// <object_type> is an optional string identifier,
//               e.g., "INDEX", "FUNCTION", "TYPE", etc.
// <name_path> is a vector giving the identifier path for the object to be
//             described.
// <from_name_path> is an optional vector giving the identifier path of a
//                    containing object, e.g. a table.
message ResolvedDescribeStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional string object_type = 2;
  repeated string name_path = 3;
  repeated string from_name_path = 4;
}

// This statement: SHOW <identifier> [FROM <name_path>] [LIKE <like_expr>];
//
// <identifier> is a string that determines the type of objects to be shown,
//              e.g., TABLES, COLUMNS, INDEXES, STATUS,
// <name_path> is an optional path to an object from which <identifier>
//             objects will be shown, e.g., if <identifier> = INDEXES and
//             <name> = table_name, the indexes of "table_name" will be
//             shown,
// <like_expr> is an optional ResolvedLiteral of type string that if present
//             restricts the objects shown to have a name like this string.
message ResolvedShowStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional string identifier = 2;
  repeated string name_path = 3;
  optional ResolvedLiteralProto like_expr = 4;
}

// This statement: BEGIN [TRANSACTION] [ <transaction_mode> [, ...] ]
//
// Where transaction_mode is one of:
//      READ ONLY
//      READ WRITE
//      <isolation_level>
//
// <isolation_level> is a string vector storing the identifiers after
//       ISOLATION LEVEL. The strings inside vector could be one of the
//       SQL standard isolation levels:
//
//                   READ UNCOMMITTED
//                   READ COMMITTED
//                   READ REPEATABLE
//                   SERIALIZABLE
//
//       or could be arbitrary strings. ZetaSQL does not validate that
//       the string is valid.
message ResolvedBeginStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional ResolvedBeginStmtEnums.ReadWriteMode read_write_mode = 3;
  repeated string isolation_level_list = 2;
}

// This statement: SET TRANSACTION <transaction_mode> [, ...]
//
// Where transaction_mode is one of:
//      READ ONLY
//      READ WRITE
//      <isolation_level>
//
// <isolation_level> is a string vector storing the identifiers after
//       ISOLATION LEVEL. The strings inside vector could be one of the
//       SQL standard isolation levels:
//
//                   READ UNCOMMITTED
//                   READ COMMITTED
//                   READ REPEATABLE
//                   SERIALIZABLE
//
//       or could be arbitrary strings. ZetaSQL does not validate that
//       the string is valid.
message ResolvedSetTransactionStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional ResolvedBeginStmtEnums.ReadWriteMode read_write_mode = 3;
  repeated string isolation_level_list = 2;
}

// This statement: COMMIT [TRANSACTION];
message ResolvedCommitStmtProto {
  optional ResolvedStatementProto parent = 1;

}

// This statement: ROLLBACK [TRANSACTION];
message ResolvedRollbackStmtProto {
  optional ResolvedStatementProto parent = 1;

}

// This statement: START BATCH [<batch_type>];
//
// <batch_type> is an optional string identifier that identifies the type of
//              the batch. (e.g. "DML" or "DDL)
message ResolvedStartBatchStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional string batch_type = 2;
}

// This statement: RUN BATCH;
message ResolvedRunBatchStmtProto {
  optional ResolvedStatementProto parent = 1;

}

// This statement: ABORT BATCH;
message ResolvedAbortBatchStmtProto {
  optional ResolvedStatementProto parent = 1;

}

// This statement: DROP <object_type> [IF EXISTS] <name_path>;
//
// <object_type> is an string identifier,
//               e.g., "TABLE", "VIEW", "INDEX", "FUNCTION", "TYPE", etc.
// <name_path> is a vector giving the identifier path for the object to be
//             dropped.
// <is_if_exists> silently ignore the "name_path does not exist" error.
message ResolvedDropStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional string object_type = 2;
  optional bool is_if_exists = 3;
  repeated string name_path = 4;
}

// This statement: DROP MATERIALIZED VIEW [IF EXISTS] <name_path>;
//
// <name_path> is a vector giving the identifier path for the object to be
//             dropped.
// <is_if_exists> silently ignore the "name_path does not exist" error.
message ResolvedDropMaterializedViewStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional bool is_if_exists = 3;
  repeated string name_path = 4;
}

// This represents a SQL WITH query (or subquery) like
//   WITH <with_query_name1> AS (<with_subquery1>),
//        <with_query_name2> AS (<with_subquery2>)
//   <query>;
//
// A <with_query_name> may be referenced (multiple times) inside a later
// with_subquery, or in the final <query>.
//
// If a WITH subquery is referenced multiple times, the full query should
// behave as if the subquery runs only once and its result is reused.
//
// There will be one ResolvedWithEntry here for each subquery in the SQL
// WITH statement, in the same order as in the query.
//
// Inside the resolved <query>, or any <with_entry_list> occurring after
// its definition, a <with_query_name> used as a table scan will be
// represented using a ResolvedWithRefScan.
//
// The <with_query_name> aliases are always unique within a query, and should
// be used to connect the ResolvedWithRefScan to the original query
// definition.  The subqueries are not inlined and duplicated into the tree.
//
// In ZetaSQL 1.0, WITH is allowed only on the outermost query and not in
// subqueries, so the ResolvedWithScan node can only occur as the outermost
// scan in a statement (e.g. a QueryStmt or CreateTableAsSelectStmt).
//
// In ZetaSQL 1.1 (language option FEATURE_V_1_1_WITH_ON_SUBQUERY), WITH
// is allowed on subqueries.  Then, ResolvedWithScan can occur anywhere in
// the tree.  The alias introduced by a ResolvedWithEntry is visible only
// in subsequent ResolvedWithEntry queries and in <query>.  The aliases used
// must be globally unique in the resolved AST however, so consumers do not
// need to implement any scoping for these names.  Because the aliases are
// unique, it is legal to collect all ResolvedWithEntries in the tree and
// treat them as if they were a single WITH clause at the outermost level.
//
// The subqueries inside ResolvedWithEntries cannot be correlated.
//
// If a WITH subquery is defined but never referenced, it will still be
// resolved and still show up here.  Query engines may choose not to run it.
//
// SQL-style WITH RECURSIVE is not currently supported.
message ResolvedWithScanProto {
  optional ResolvedScanProto parent = 1;

  repeated ResolvedWithEntryProto with_entry_list = 2;
  optional AnyResolvedScanProto query = 3;
}

// This represents one aliased subquery introduced in a WITH clause.
//
// The <with_query_name>s must be globally unique in the full resolved AST.
// The <with_subquery> cannot be correlated and cannot reference any
// columns from outside.  It may reference other WITH subqueries.
//
// See ResolvedWithScan for full details.
message ResolvedWithEntryProto {
  optional ResolvedArgumentProto parent = 1;

  optional string with_query_name = 2;
  optional AnyResolvedScanProto with_subquery = 3;
}

// This represents one SQL hint key/value pair.
// The SQL syntax @{ key1=value1, key2=value2, some_db.key3=value3 }
// will expand to three ResolvedOptions.  Keyword hints (e.g. LOOKUP JOIN)
// are interpreted as shorthand, and will be expanded to a ResolvedOption
// attached to the appropriate node before any explicit long-form hints.
//
// ResolvedOptions are attached to the ResolvedScan corresponding to the
// operator that the SQL hint was associated with.
// See (broken link) for more detail.
// Hint semantics are implementation defined.
//
// Each hint is resolved as a [<qualifier>.]<name>:=<value> pair.
//   <qualifier> will be empty if no qualifier was present.
//   <name> is always non-empty.
//   <value> can be a ResolvedLiteral or a ResolvedParameter,
//           a cast of a ResolvedParameter (for typed hints only),
//           or a general expression (on constant inputs).
//
// If AllowedHintsAndOptions was set in AnalyzerOptions, and this hint or
// option was included there and had an expected type, the type of <value>
// will match that expected type.  Unknown hints (not listed in
// AllowedHintsAndOptions) are not stripped and will still show up here.
//
// If non-empty, <qualifier> should be interpreted as a target system name,
// and a database system should ignore any hints targeted to different
// systems.
//
// The SQL syntax allows using an identifier as a hint value.
// Such values are stored here as ResolvedLiterals with string type.
message ResolvedOptionProto {
  optional ResolvedArgumentProto parent = 1;

  optional string qualifier = 2;
  optional string name = 3;
  optional AnyResolvedExprProto value = 4;
}

// Window partitioning specification for an analytic function call.
//
// PARTITION BY keys in <partition_by_list>.
message ResolvedWindowPartitioningProto {
  optional ResolvedArgumentProto parent = 1;

  repeated ResolvedColumnRefProto partition_by_list = 2;
  repeated ResolvedOptionProto hint_list = 3;
}

// Window ordering specification for an analytic function call.
//
// ORDER BY items in <order_by_list>. There should be exactly one ORDER
// BY item if this is a window ORDER BY for a RANGE-based window.
message ResolvedWindowOrderingProto {
  optional ResolvedArgumentProto parent = 1;

  repeated ResolvedOrderByItemProto order_by_item_list = 2;
  repeated ResolvedOptionProto hint_list = 3;
}

// Window framing specification for an analytic function call.
//
// ROW-based window frames compute the frame based on physical offsets
// from the current row.
// RANGE-based window frames compute the frame based on a logical
// range of rows around the current row based on the current row's
// ORDER BY key value.
//
// <start_expr> and <end_expr> cannot be NULL. If the window frame
// is one-sided in the input query, the resolver will generate an
// implicit ending boundary.
message ResolvedWindowFrameProto {
  optional ResolvedArgumentProto parent = 1;

  optional ResolvedWindowFrameEnums.FrameUnit frame_unit = 2;
  optional ResolvedWindowFrameExprProto start_expr = 3;
  optional ResolvedWindowFrameExprProto end_expr = 4;
}

// This represents a group of analytic function calls that shares PARTITION
// BY and ORDER BY.
//
// <partition_by> can be NULL. <order_by> may be NULL depending on the
// functions in <analytic_function_list> and the window frame unit. See
// (broken link) for more details.
//
// All expressions in <analytic_function_list> have a
// ResolvedAggregateFunctionCall with a function in mode
// Function::AGGREGATE or Function::ANALYTIC.
message ResolvedAnalyticFunctionGroupProto {
  optional ResolvedArgumentProto parent = 1;

  optional ResolvedWindowPartitioningProto partition_by = 2;
  optional ResolvedWindowOrderingProto order_by = 3;
  repeated ResolvedComputedColumnProto analytic_function_list = 4;
}

// Window frame boundary expression that determines the first/last row of
// the moving window for each tuple.
//
// <expression> cannot be NULL if the type is OFFSET_PRECEDING
// or OFFSET_FOLLOWING. It must be a constant expression. If this is a
// boundary for a ROW-based window, it must be integer type. Otherwise,
// it must be numeric type and must match exactly the type of the window
// ordering expression.  See (broken link) for more
// details.
message ResolvedWindowFrameExprProto {
  optional ResolvedArgumentProto parent = 1;

  optional ResolvedWindowFrameExprEnums.BoundaryType boundary_type = 2;
  optional AnyResolvedExprProto expression = 3;
}

// This represents a value inside an INSERT or UPDATE statement.
//
// The <value> is either an expression or a DMLDefault.
//
// For proto fields, NULL values mean the field should be cleared.
message ResolvedDMLValueProto {
  optional ResolvedArgumentProto parent = 1;

  optional AnyResolvedExprProto value = 2;
}

// This is used to represent the value DEFAULT that shows up (in place of a
// value expression) in INSERT and UPDATE statements.
// For columns, engines should substitute the engine-defined default value
// for that column, or give an error.
// For proto fields, this always means to clear the field.
// This will never show up inside expressions other than ResolvedDMLValue.
message ResolvedDMLDefaultProto {
  optional ResolvedExprProto parent = 1;

}

// This represents the ASSERT statement:
//   ASSERT <expression> [AS <description>];
//
// <expression> is any expression that returns a bool.
// <description> is an optional string literal used to give a more
// descriptive error message in case the ASSERT fails.
message ResolvedAssertStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional AnyResolvedExprProto expression = 2;
  optional string description = 3;
}

// This represents the ASSERT ROWS MODIFIED clause on a DML statement.
// The value must be a literal or (possibly casted) parameter int64.
//
// The statement should fail if the number of rows updated does not
// exactly match this number.
message ResolvedAssertRowsModifiedProto {
  optional ResolvedArgumentProto parent = 1;

  optional AnyResolvedExprProto rows = 2;
}

// This represents one row in the VALUES clause of an INSERT.
message ResolvedInsertRowProto {
  optional ResolvedArgumentProto parent = 1;

  repeated ResolvedDMLValueProto value_list = 2;
}

// This represents an INSERT statement, or a nested INSERT inside an
// UPDATE statement.
//
// For top-level INSERT statements, <table_scan> gives the table to
// scan and creates ResolvedColumns for its columns.  Those columns can be
// referenced in <insert_column_list>.
//
// For nested INSERTS, there is no <table_scan> or <insert_column_list>.
// There is implicitly a single column to insert, and its type is the
// element type of the array being updated in the ResolvedUpdateItem
// containing this statement.
//
// For nested INSERTs, alternate modes are not supported and <insert_mode>
// will always be set to OR_ERROR.
//
// The rows to insert come from <row_list> or the result of <query>.
// Exactly one of these must be present.
//
// If <row_list> is present, the columns in the row_list match
// positionally with <insert_column_list>.
//
// If <query> is present, <query_output_column_list> must also be present.
// <query_output_column_list> is the list of output columns produced by
// <query> that correspond positionally with the target <insert_column_list>
// on the output table.  For nested INSERTs with no <insert_column_list>,
// <query_output_column_list> must have exactly one column.
//
// <query_parameter_list> is set for nested INSERTs where <query> is set and
// references non-target values (columns or field values) from the table. It
// is only set when FEATURE_V_1_2_CORRELATED_REFS_IN_NESTED_DML is enabled.
message ResolvedInsertStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional ResolvedTableScanProto table_scan = 2;
  // Behavior on duplicate rows (normally defined to mean duplicate
  // primary keys).
  optional ResolvedInsertStmtEnums.InsertMode insert_mode = 3;
  optional ResolvedAssertRowsModifiedProto assert_rows_modified = 4;
  repeated ResolvedColumnProto insert_column_list = 5;
  repeated ResolvedColumnRefProto query_parameter_list = 9;
  optional AnyResolvedScanProto query = 6;
  repeated ResolvedColumnProto query_output_column_list = 8;
  repeated ResolvedInsertRowProto row_list = 7;
}

// This represents a DELETE statement or a nested DELETE inside an
// UPDATE statement.
//
// For top-level DELETE statements, <table_scan> gives the table to
// scan and creates ResolvedColumns for its columns.  Those columns can
// be referenced inside the <where_expr>.
//
// For nested DELETEs, there is no <table_scan>.  The <where_expr> can
// only reference:
//   (1) the element_column from the ResolvedUpdateItem containing this
//       statement,
//   (2) columns from the outer statements, and
//   (3) (optionally) <array_offset_column>, which represents the 0-based
//       offset of the array element being modified.
//
// <where_expr> is required.
message ResolvedDeleteStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional ResolvedTableScanProto table_scan = 2;
  optional ResolvedAssertRowsModifiedProto assert_rows_modified = 3;
  optional ResolvedColumnHolderProto array_offset_column = 5;
  optional AnyResolvedExprProto where_expr = 4;
}

// This represents one item inside the SET clause of an UPDATE.
//
// The entity being updated is specified by <target>.
//
// For a regular
//   SET {target} = {expression} | DEFAULT
// clause (not including an array element update like SET a[OFFSET(0)] = 5),
// <target> and <set_value> will be present, and all other fields will be
// unset.
//
// For an array element update (e.g. SET a.b[<expr>].c = <value>),
//   - <target> is set to the array,
//   - <element_column> is a new ResolvedColumn that can be used inside the
//     update items to refer to the array element.
//   - <array_update_list> will have a node corresponding to the offset into
//     that array and the modification to that array element.
// For example, for SET a.b[<expr>].c = <value>, we have
//    ResolvedUpdateItem
//    +-<target> = a.b
//    +-<element_column> = <x>
//    +-<array_update_list>
//      +-ResolvedUpdateArrayItem
//        +-<offset> = <expr>
//        +-<update_item> = ResolvedUpdateItem
//          +-<target> = <x>.c
//          +-<set_value> = <value>
//
// The engine is required to fail the update if there are two elements of
// <array_update_list> corresponding to offset expressions that evaluate to
// the same value. These are considered to be conflicting updates.
//
// Multiple updates to the same array are always represented as multiple
// elements of <array_update_list> under a single ResolvedUpdateItem
// corresponding to that array. <array_update_list> will only have one
// element for modifications to an array-valued subfield of an array element.
// E.g., for SET a[<expr1>].b[<expr2>] = 5, a[<expr3>].b[<expr4>] = 6, we
// will have:
//     ResolvedUpdateItem
//     +-<target> = a
//     +-<element_column> = x
//     +-<array_update_list>
//       +-ResolvedUpdateArrayItem
//         +-<offset> = <expr1>
//         +-ResolvedUpdateItem for <x>.b[<expr2>] = 5
//       +-ResolvedUpdateArrayItem
//         +-<offset> = <expr3>
//         +-ResolvedUpdateItem for <x>.b[<expr4>] = 6
// The engine must give a runtime error if <expr1> and <expr3> evaluate to
// the same thing. Notably, it does not have to understand that the
// two ResolvedUpdateItems corresponding to "b" refer to the same array iff
// <expr1> and <expr3> evaluate to the same thing.
//
// TODO: Consider allowing the engine to execute an update like
// SET a[<expr1>].b = 1, a[<expr2>].c = 2 even if <expr1> == <expr2> since
// "b" and "c" do not overlap. Also consider allowing a more complex example
// like SET a[<expr1>].b[<expr2>] = ...,
// a[<expr3>].b[<expr4>].c[<expr5>] = ... even if <expr1> == <expr3>, as long
// as <expr2> != <expr4> in that case.
//
// For nested DML, <target> and <element_column> will both be set, and one or
// more of the nested statement lists will be non-empty. <target> must have
// ARRAY type, and <element_column> introduces a ResolvedColumn representing
// elements of that array. The nested statement lists will always be empty in
// a ResolvedUpdateItem child of a ResolvedUpdateArrayItem node.
//
// See (broken link) for more detail.
message ResolvedUpdateItemProto {
  optional ResolvedArgumentProto parent = 1;

  // The target entity to be updated.
  //
  // This is an expression evaluated using the ResolvedColumns visible
  // inside this statement.  This expression can contain only
  // ResolvedColumnRefs, ResolvedGetProtoField and
  // ResolvedGetStructField nodes.
  //
  // In a top-level UPDATE, the expression always starts with a
  // ResolvedColumnRef referencing a column from the statement's
  // TableScan.
  //
  // In a nested UPDATE, the expression always starts with a
  // ResolvedColumnRef referencing the element_column from the
  // ResolvedUpdateItem containing this scan.
  //
  // This node is also used to represent a modification of a single
  // array element (when it occurs as a child of a
  // ResolvedUpdateArrayItem node).  In that case, the expression
  // starts with a ResolvedColumnRef referencing the <element_column>
  // from its grandparent ResolvedUpdateItem. (E.g., for "SET a[<expr>]
  // = 5", the grandparent ResolvedUpdateItem has <target> "a", the
  // parent ResolvedUpdateArrayItem has offset <expr>, and this node
  // has <set_value> 5 and target corresponding to the grandparent's
  // <element_column> field.)
  //
  // For either a nested UPDATE or an array modification, there may be
  // a path of field accesses after the initial ResolvedColumnRef,
  // represented by a chain of GetField nodes.
  //
  // NOTE: We use the same GetField nodes as we do for queries, but
  // they are not treated the same.  Here, they express a path inside
  // an object that is being mutated, so they have reference semantics.
  optional AnyResolvedExprProto target = 2;
  // Set the target entity to this value.  The types must match.
  // This can contain the same columns that can appear in the
  // <where_expr> of the enclosing ResolvedUpdateStmt.
  //
  // This is mutually exclusive with all fields below, which are used
  // for nested updates only.
  optional ResolvedDMLValueProto set_value = 3;
  // The ResolvedColumn introduced to represent the elements of the
  // array being updated.  This works similarly to
  // ArrayScan::element_column.
  //
  // <target> must have array type, and this column has the array's
  // element type.
  //
  // This column can be referenced inside the nested statements below.
  optional ResolvedColumnHolderProto element_column = 4;
  // Array element modifications to apply. Each item runs on the value
  // of <element_column> specified by ResolvedUpdateArrayItem.offset.
  // This field is always empty if the analyzer option
  // FEATURE_V_1_2_ARRAY_ELEMENTS_WITH_SET is disabled.
  //
  // The engine must fail if two elements in this list have offset
  // expressions that evaluate to the same value.
  // TODO: Consider generalizing this to allow
  // SET a[<expr1>].b = ..., a[<expr2>].c = ...
  repeated ResolvedUpdateArrayItemProto array_update_list = 8;
  // Nested DELETE statements to apply.  Each delete runs on one value
  // of <element_column> and may choose to delete that array element.
  //
  // DELETEs are applied before INSERTs or UPDATEs.
  //
  // It is legal for the same input element to match multiple DELETEs.
  repeated ResolvedDeleteStmtProto delete_list = 5;
  // Nested UPDATE statements to apply.  Each update runs on one value
  // of <element_column> and may choose to update that array element.
  //
  // UPDATEs are applied after DELETEs and before INSERTs.
  //
  // It is an error if any element is matched by multiple UPDATEs.
  repeated ResolvedUpdateStmtProto update_list = 6;
  // Nested INSERT statements to apply.  Each insert will produce zero
  // or more values for <element_column>.
  //
  // INSERTs are applied after DELETEs and UPDATEs.
  //
  // For nested UPDATEs, insert_mode will always be the default, and
  // has no effect.
  repeated ResolvedInsertStmtProto insert_list = 7;
}

// For an array element modification, this node represents the offset
// expression and the modification, but not the array. E.g., for
// SET a[<expr>] = 5, this node represents a modification of "= 5" to offset
// <expr> of the array defined by the parent node.
message ResolvedUpdateArrayItemProto {
  optional ResolvedArgumentProto parent = 1;

  // The array offset to be modified.
  optional AnyResolvedExprProto offset = 2;
  // The modification to perform to the array element.
  optional ResolvedUpdateItemProto update_item = 3;
}

// This represents an UPDATE statement, or a nested UPDATE inside an
// UPDATE statement.
//
// For top-level UPDATE statements, <table_scan> gives the table to
// scan and creates ResolvedColumns for its columns.  Those columns can be
// referenced in the <update_item_list>. The top-level UPDATE statement may
// also have <from_scan>, the output of which is joined with
// the <table_scan> using expressions in the <where_expr>. The columns
// exposed in the <from_scan> are visible in the right side of the
// expressions in the <update_item_list> and in the <where_expr>.
// <array_offset_column> is never set for top-level UPDATE statements.
//
// Top-level UPDATE statements will also have <column_access_list> populated.
// For each column, this vector indicates if the column was read and/or
// written. The columns in this vector match those of
// <table_scan.column_list>. If a column was not encountered when producing
// the resolved AST, then the value at that index will be
// ResolvedStatement::NONE.
//
// For nested UPDATEs, there is no <table_scan>.  The <where_expr> can
// only reference:
//   (1) the element_column from the ResolvedUpdateItem containing this
//       statement,
//   (2) columns from the outer statements, and
//   (3) (optionally) <array_offset_column>, which represents the 0-based
//       offset of the array element being modified.
// The left hand sides of the expressions in <update_item_list> can only
// reference (1). The right hand sides of those expressions can reference
// (1), (2), and (3).
//
// The updates in <update_item_list> will be non-overlapping.
// If there are multiple nested statements updating the same entity,
// they will be combined into one ResolvedUpdateItem.
//
// See (broken link) for more detail on nested DML.
message ResolvedUpdateStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional ResolvedTableScanProto table_scan = 2;
  repeated ResolvedStatementEnums.ObjectAccess column_access_list = 8;
  optional ResolvedAssertRowsModifiedProto assert_rows_modified = 3;
  optional ResolvedColumnHolderProto array_offset_column = 7;
  optional AnyResolvedExprProto where_expr = 4;
  repeated ResolvedUpdateItemProto update_item_list = 5;
  optional AnyResolvedScanProto from_scan = 6;
}

// This is used by ResolvedMergeStmt to represent one WHEN ... THEN clause
// within MERGE statement.
//
// There are three types of clauses, which are MATCHED, NOT_MATCHED_BY_SOURCE
// and NOT_MATCHED_BY_TARGET. The <match_type> must have one of these values.
//
// The <match_expr> defines an optional expression to apply to the join
// result of <table_scan> and <from_scan> of the parent ResolvedMergeStmt.
//
// Each ResolvedMergeWhen must define exactly one of three operations,
//   -- INSERT: <action_type> is ResolvedMergeWhen::INSERT.
//              Both <insert_column_list> and <insert_row> are non-empty.
//              The size of <insert_column_list> must be the same with the
//              value_list size of <insert_row>, and, the column data type
//              must match.
//   -- UPDATE: <action_type> is ResolvedMergeWhen::UPDATE.
//              <update_item_list> is non-empty.
//   -- DELETE: <action_type> is ResolvedMergeWhen::DELETE.
// The INSERT, UPDATE and DELETE operations are mutually exclusive.
//
// When <match_type> is MATCHED, <action_type> must be UPDATE or DELETE.
// When <match_type> is NOT_MATCHED_BY_TARGET, <action_type> must be INSERT.
// When <match_type> is NOT_MATCHED_BY_SOURCE, <action_type> must be UPDATE
// or DELETE.
//
// The column visibility within a ResolvedMergeWhen clause is defined as
// following,
//   -- When <match_type> is MATCHED,
//      -- All columns from <table_scan> and <from_scan> are allowed in
//         <match_expr>.
//      -- If <action_type> is UPDATE, only columns from <table_scan> are
//         allowed on left side of expressions in <update_item_list>.
//         All columns from <table_scan> and <from_scan> are allowed on right
//         side of expressions in <update_item_list>.
//   -- When <match_type> is NOT_MATCHED_BY_TARGET,
//      -- Only columns from <from_scan> are allowed in <match_expr>.
//      -- Only columns from <table_scan> are allowed in
//         <insert_column_list>.
//      -- Only columns from <from_scan> are allowed in <insert_row>.
//   -- When <match_type> is NOT_MATCHED_BY_SOURCE,
//      -- Only columns from <table_scan> are allowed in <match_expr>.
//      -- If <action_type> is UPDATE, only columns from <table_scan> are
//         allowed in <update_item_list>.
message ResolvedMergeWhenProto {
  optional ResolvedArgumentProto parent = 1;

  optional ResolvedMergeWhenEnums.MatchType match_type = 2;
  optional AnyResolvedExprProto match_expr = 3;
  optional ResolvedMergeWhenEnums.ActionType action_type = 4;
  repeated ResolvedColumnProto insert_column_list = 5;
  optional ResolvedInsertRowProto insert_row = 6;
  repeated ResolvedUpdateItemProto update_item_list = 7;
}

// This represents a MERGE statement.
//
// <table_scan> gives the target table to scan and creates ResolvedColumns
// for its columns.
//
// <column_access_list> indicates for each column, whether it was read and/or
// written. The columns in this vector match those of
// <table_scan.column_list>. If a column was not encountered when producing
// the resolved AST, then the value at that index will be
// ResolvedStatement::NONE(0).
//
// The output of <from_scan> is joined with <table_scan> using the join
// expression <merge_expr>.
//
// The order of elements in <when_clause_list> matters, as they are executed
// sequentially. At most one of the <when_clause_list> clause will be applied
// to each row from <table_scan>.
//
// <table_scan>, <from_scan>, <merge_expr> and <when_clause_list> are
// required. <when_clause_list> must be non-empty.
//
// See (broken link) for more detail on MERGE statement.
message ResolvedMergeStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional ResolvedTableScanProto table_scan = 2;
  repeated ResolvedStatementEnums.ObjectAccess column_access_list = 6;
  optional AnyResolvedScanProto from_scan = 3;
  optional AnyResolvedExprProto merge_expr = 4;
  repeated ResolvedMergeWhenProto when_clause_list = 5;
}

// This represents a TRUNCATE TABLE statement.
//
// Statement:
//   TRUNCATE TABLE <table_name> [WHERE <boolean_expression>]
//
// <table_scan> is a TableScan for the target table, which is used during
//              resolving and validation. Consumers can use either the table
//              object inside it or name_path to reference the table.
// <where_expr> boolean expression that can reference columns in
//              ResolvedColumns (which the TableScan creates); the
//              <where_expr> should always correspond to entire partitions,
//              and is optional.
message ResolvedTruncateStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional ResolvedTableScanProto table_scan = 3;
  optional AnyResolvedExprProto where_expr = 4;
}

// A grantable privilege.
//
// <action_type> is the type of privilege action, e.g. SELECT, INSERT, UPDATE
// or DELETE.
// <unit_list> is an optional list of units of the object (e.g. columns of a
// table) the privilege is restricted to. Privilege on the whole object
// should be granted/revoked if the list is empty.
message ResolvedPrivilegeProto {
  optional ResolvedArgumentProto parent = 1;

  optional string action_type = 2;
  repeated string unit_list = 3;
}

// Common superclass of GRANT/REVOKE statements.
//
// <privilege_list> is the list of privileges to be granted/revoked. ALL
// PRIVILEGES should be granted/fromed if it is empty.
// <object_type> is an optional string identifier, e.g., TABLE, VIEW.
// <name_path> is a vector of segments of the object identifier's pathname.
// <grantee_list> (DEPRECATED) is the list of grantees (strings).
// <grantee_expr_list> is the list of grantees, and may include parameters.
//
// Only one of <grantee_list> or <grantee_expr_list> will be populated,
// depending on whether or not the FEATURE_PARAMETERS_IN_GRANTEE_LIST
// is enabled.  The <grantee_list> is deprecated, and will be removed
// along with the corresponding FEATURE once all engines have migrated to
// use the <grantee_expr_list>.  Once <grantee_expr_list> is the only
// one, then it should be marked as NOT_IGNORABLE.
message AnyResolvedGrantOrRevokeStmtProto {
  oneof node {
    ResolvedGrantStmtProto resolved_grant_stmt_node = 69;
    ResolvedRevokeStmtProto resolved_revoke_stmt_node = 70;
  }
}

message ResolvedGrantOrRevokeStmtProto {
  optional ResolvedStatementProto parent = 1;

  repeated ResolvedPrivilegeProto privilege_list = 2;
  optional string object_type = 3;
  repeated string name_path = 4;
  repeated string grantee_list = 5;
  repeated AnyResolvedExprProto grantee_expr_list = 6;
}

// A GRANT statement. It represents the action to grant a list of privileges
// on a specific object to/from list of grantees.
message ResolvedGrantStmtProto {
  optional ResolvedGrantOrRevokeStmtProto parent = 1;

}

// A REVOKE statement. It represents the action to revoke a list of
// privileges on a specific object to/from list of grantees.
message ResolvedRevokeStmtProto {
  optional ResolvedGrantOrRevokeStmtProto parent = 1;

}

// Common super class for statements:
//   ALTER <object> [IF EXISTS] <name_path> <alter_action_list>
//
// <name_path> is a vector giving the identifier path in the table <name>.
// <alter_action_list> is a vector of actions to be done to the object.
// <is_if_exists> silently ignores the "name_path does not exist" error.
message AnyResolvedAlterObjectStmtProto {
  oneof node {
    ResolvedAlterRowAccessPolicyStmtProto resolved_alter_row_access_policy_stmt_node = 75;
    ResolvedAlterTableStmtProto resolved_alter_table_stmt_node = 115;
    ResolvedAlterViewStmtProto resolved_alter_view_stmt_node = 118;
    ResolvedAlterMaterializedViewStmtProto resolved_alter_materialized_view_stmt_node = 127;
    ResolvedAlterDatabaseStmtProto resolved_alter_database_stmt_node = 134;
  }
}

message ResolvedAlterObjectStmtProto {
  optional ResolvedStatementProto parent = 1;

  repeated string name_path = 2;
  repeated AnyResolvedAlterActionProto alter_action_list = 3;
  optional bool is_if_exists = 4;
}

// This statement:
//   ALTER DATABASE [IF EXISTS] <name_path> <alter_action_list>
//
// This statement could be used to change the database level options.
message ResolvedAlterDatabaseStmtProto {
  optional ResolvedAlterObjectStmtProto parent = 1;

}

// This statement:
// ALTER MATERIALIZED VIEW [IF EXISTS] <name_path> <alter_action_list>
message ResolvedAlterMaterializedViewStmtProto {
  optional ResolvedAlterObjectStmtProto parent = 1;

}

// This statement:
// ALTER TABLE [IF EXISTS] <name_path> <alter_action_list>
message ResolvedAlterTableStmtProto {
  optional ResolvedAlterObjectStmtProto parent = 1;

}

// This statement:
// ALTER VIEW [IF EXISTS] <name_path> <alter_action_list>
message ResolvedAlterViewStmtProto {
  optional ResolvedAlterObjectStmtProto parent = 1;

}

// A common super class for all actions in statement ALTER <object>
message AnyResolvedAlterActionProto {
  oneof node {
    ResolvedSetOptionsActionProto resolved_set_options_action_node = 117;
    ResolvedAddColumnActionProto resolved_add_column_action_node = 131;
    ResolvedDropColumnActionProto resolved_drop_column_action_node = 132;
    ResolvedGrantToActionProto resolved_grant_to_action_node = 135;
    ResolvedFilterUsingActionProto resolved_filter_using_action_node = 136;
    ResolvedRevokeFromActionProto resolved_revoke_from_action_node = 137;
    ResolvedRenameToActionProto resolved_rename_to_action_node = 138;
  }
}

message ResolvedAlterActionProto {
  optional ResolvedArgumentProto parent = 1;

}

// SET OPTIONS action for ALTER <object> statement
//
// <option_list> has engine-specific directives that specify how to
//               alter the metadata for this object.
message ResolvedSetOptionsActionProto {
  optional ResolvedAlterActionProto parent = 1;

  repeated ResolvedOptionProto option_list = 2;
}

// ADD COLUMN action for ALTER TABLE statement
message ResolvedAddColumnActionProto {
  optional ResolvedAlterActionProto parent = 1;

  optional bool is_if_not_exists = 2;
  optional ResolvedColumnDefinitionProto column_definition = 3;
}

// DROP COLUMN action for ALTER TABLE statement
//
// <name> is the name of the column to drop.
// <column_reference> references the column to be dropped, if it exists.
//        It might be missing if DROP IF EXISTS column does not exist.
message ResolvedDropColumnActionProto {
  optional ResolvedAlterActionProto parent = 1;

  optional bool is_if_exists = 2;
  optional string name = 3;
  optional ResolvedColumnRefProto column_reference = 4;
}

// This statement:
//   ALTER TABLE [IF EXISTS] <name> SET OPTIONS (...)
//
// NOTE: This is deprecated in favor of ResolvedAlterTableStmt.
//
// <name_path> is a vector giving the identifier path in the table <name>.
// <option_list> has engine-specific directives that specify how to
//               alter the metadata for this table.
// <is_if_exists> silently ignore the "name_path does not exist" error.
message ResolvedAlterTableSetOptionsStmtProto {
  optional ResolvedStatementProto parent = 1;

  repeated string name_path = 2;
  repeated ResolvedOptionProto option_list = 3;
  optional bool is_if_exists = 4;
}

// This statement: RENAME <object_type> <old_name_path> TO <new_name_path>;
//
// <object_type> is an string identifier,
//               e.g., "TABLE", "VIEW", "INDEX", "FUNCTION", "TYPE", etc.
// <old_name_path> is a vector giving the identifier path for the object to
//                 be renamed.
// <new_name_path> is a vector giving the identifier path for the object to
//                 be renamed to.
message ResolvedRenameStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional string object_type = 2;
  repeated string old_name_path = 3;
  repeated string new_name_path = 4;
}

// This statement: CREATE [OR REPLACE] ROW ACCESS POLICY [IF NOT EXISTS]
//                 [<name>] ON <target_name_path>
//                 [GRANT TO (<grantee_list>)]
//                 FILTER USING (<predicate>);
//
// <create_mode> indicates if this was CREATE, CREATE OR REPLACE, or
//               CREATE IF NOT EXISTS.
// <name> is the name of the row access policy to be created or an empty
//        string.
// <target_name_path> is a vector giving the identifier path of the target
//                    table.
// <table_scan> is a TableScan for the target table, which is used during
//              resolving and validation. Consumers can use either the table
//              object inside it or target_name_path to reference the table.
// <grantee_list> (DEPRECATED) is the list of user principals the policy
//                should apply to.
// <grantee_expr_list> is the list of user principals the policy should
//                     apply to, and may include parameters.
// <predicate> is a boolean expression that selects the rows that are being
//             made visible.
// <predicate_str> is the string form of the predicate.
//
// Only one of <grantee_list> or <grantee_expr_list> will be populated,
// depending on whether or not the FEATURE_PARAMETERS_IN_GRANTEE_LIST
// is enabled.  The <grantee_list> is deprecated, and will be removed
// along with the corresponding FEATURE once all engines have migrated to
// use the <grantee_expr_list>.  Once <grantee_expr_list> is the only
// one, then it should be marked as NOT_IGNORABLE.
message ResolvedCreateRowAccessPolicyStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional ResolvedCreateStatementEnums.CreateMode create_mode = 2;
  optional string name = 3;
  repeated string target_name_path = 4;
  repeated string grantee_list = 5;
  repeated AnyResolvedExprProto grantee_expr_list = 9;
  optional ResolvedTableScanProto table_scan = 6;
  optional AnyResolvedExprProto predicate = 7;
  optional string predicate_str = 8;
}

// This statement:
//     DROP ROW ACCESS POLICY <name> ON <target_name_path>; or
//     DROP ALL ROW [ACCESS] POLICIES ON <target_name_path>;
//
// <is_drop_all> indicates that all policies should be dropped.
// <is_if_exists> silently ignore the "policy <name> does not exist" error.
//                This is not allowed if is_drop_all is true.
// <name> is the name of the row policy to be dropped or an empty string.
// <target_name_path> is a vector giving the identifier path of the target
//                    table.
message ResolvedDropRowAccessPolicyStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional bool is_drop_all = 2;
  optional bool is_if_exists = 3;
  optional string name = 4;
  repeated string target_name_path = 5;
}

// GRANT TO action for ALTER ROW ACCESS POLICY statement
//
// <grantee_expr_list> is the list of grantees, and may include parameters.
message ResolvedGrantToActionProto {
  optional ResolvedAlterActionProto parent = 1;

  repeated AnyResolvedExprProto grantee_expr_list = 2;
}

// FILTER USING action for ALTER ROW ACCESS POLICY statement
//
// <predicate> is a boolean expression that selects the rows that are being
//             made visible.
// <predicate_str> is the string form of the predicate.
message ResolvedFilterUsingActionProto {
  optional ResolvedAlterActionProto parent = 1;

  optional AnyResolvedExprProto predicate = 2;
  optional string predicate_str = 3;
}

// REVOKE FROM action for ALTER ROW ACCESS POLICY statement
//
// <revokee_expr_list> is the list of revokees, and may include parameters.
// <is_revoke_from_all> is a boolean indicating whether it was a REVOKE FROM
//                      ALL statement.
message ResolvedRevokeFromActionProto {
  optional ResolvedAlterActionProto parent = 1;

  repeated AnyResolvedExprProto revokee_expr_list = 2;
  optional bool is_revoke_from_all = 3;
}

// RENAME TO action for ALTER ROW ACCESS POLICY statement
//
// <new_name> is the new name of the row access policy.
message ResolvedRenameToActionProto {
  optional ResolvedAlterActionProto parent = 1;

  optional string new_name = 2;
}

// This statement:
//     ALTER ROW ACCESS POLICY [IF EXISTS]
//     <name> ON <name_path>
//     <alter_action_list>
//
// <name> is the name of the row access policy to be altered, scoped to the
//        table in the base <name_path>.
// <table_scan> is a TableScan for the target table, which is used during
//              resolving and validation. Consumers can use either the table
//              object inside it or base <name_path> to reference the table.
message ResolvedAlterRowAccessPolicyStmtProto {
  optional ResolvedAlterObjectStmtProto parent = 1;

  optional string name = 2;
  optional ResolvedTableScanProto table_scan = 6;
}

// This statement creates a user-defined named constant:
// CREATE [OR REPLACE] [TEMP | TEMPORARY | PUBLIC | PRIVATE] CONSTANT
//   [IF NOT EXISTS] <name_path> = <expression>
//
// <name_path> is the identifier path of the named constants.
// <expr> is the expression that determines the type and the value of the
//        named constant. Note that <expr> need not be constant. Its value
//        is bound to the named constant which is then treated as
//        immutable. <expr> can be evaluated at the time this statement is
//        processed or later (lazy evaluation during query execution).
message ResolvedCreateConstantStmtProto {
  optional ResolvedCreateStatementProto parent = 1;

  optional AnyResolvedExprProto expr = 2;
}

// This statement creates a user-defined function:
//   CREATE [TEMP] FUNCTION [IF NOT EXISTS] <name_path> (<arg_list>)
//     [RETURNS <return_type>] [<determinism_level>] [LANGUAGE <language>]
//     [AS <code> | AS ( <function_expression> )] [OPTIONS (<option_list>)]
//
//   <name_path> is the identifier path of the function.
//   <has_explicit_return_type> is true iff RETURNS clause is present.
//   <return_type> is the return type for the function, which can be any
//          valid ZetaSQL type, including ARRAY or STRUCT. It is inferred
//          from <function_expression> if not explicitly set.
//          TODO: Deprecate and remove this. The return type is
//          already specified by the <signature>.
//   <argument_name_list> The names of the function arguments.
//   <signature> is the FunctionSignature of the created function, with all
//          options.  This can be used to create a Function to load into a
//          Catalog for future queries.
//   <is_aggregate> is true if this is an aggregate function.  All arguments
//          are assumed to be aggregate input arguments that may vary for
//          every row.
//   <language> is the programming language used by the function. This field
//          is set to 'SQL' for SQL functions and otherwise to the language
//          name specified in the LANGUAGE clause.
//   <code> is a string literal that contains the function definition.  Some
//          engines may allow this argument to be omitted for certain types
//          of external functions. This will always be set for SQL functions.
//   <aggregate_expression_list> is a list of SQL aggregate functions to
//          compute prior to computing the final <function_expression>.
//          See below.
//   <function_expression> is the resolved SQL expression invoked for the
//          function. This will be unset for external language functions. For
//          non-template SQL functions, this is a resolved representation of
//          the expression in <code>.
//   <option_list> has engine-specific directives for modifying functions.
//   <sql_security> is the declared security mode for the function. Values
//          include 'INVOKER', 'DEFINER'.
//   <determinism_level> is the declared determinism level of the function.
//          Values are 'DETERMINISTIC', 'NOT DETERMINISTIC', 'IMMUTABLE',
//          'STABLE', 'VOLATILE'.
//
// Note that <function_expression> and <code> are both marked as IGNORABLE
// because an engine could look at either one (but might not look at both).
// An engine must look at one (and cannot ignore both) to be semantically
// valid, but there is currently no way to enforce that.
//
// For aggregate functions, <is_aggregate> will be true.
// Aggregate functions will only occur if LanguageOptions has
// FEATURE_CREATE_AGGREGATE_FUNCTION enabled.
//
// Arguments to aggregate functions must have
// <FunctionSignatureArgumentTypeOptions::is_not_aggregate> true or false.
// Non-aggregate arguments must be passed constant values only.
//
// For SQL aggregate functions, there will be both an
// <aggregate_expression_list>, with aggregate expressions to compute first,
// and then a final <function_expression> to compute on the results
// of the aggregates.  Each aggregate expression is a
// ResolvedAggregateFunctionCall, and may reference any input arguments.
// Each ResolvedComputedColumn in <aggregate_expression_list> gives the
// aggregate expression a column id.  The final <function_expression> can
// reference these created aggregate columns, and any input arguments
// with <argument_kind>=NOT_AGGREGATE.
//
// For example, with
//   CREATE TEMP FUNCTION my_avg(x) = (SUM(x) / COUNT(x));
// we would have an <aggregate_expression_list> with
//   agg1#1 := SUM(ResolvedArgumentRef(x))
//   agg2#2 := COUNT(ResolvedArgumentRef(x))
// and a <function_expression>
//   ResolvedColumnRef(agg1#1) / ResolvedColumnRef(agg2#2)
//
// For example, with
//   CREATE FUNCTION scaled_avg(x,y NOT AGGREGATE) = (SUM(x) / COUNT(x) * y);
// we would have an <aggregate_expression_list> with
//   agg1#1 := SUM(ResolvedArgumentRef(x))
//   agg2#2 := COUNT(ResolvedArgumentRef(x))
// and a <function_expression>
//   ResolvedColumnRef(agg1#1) / ResolvedColumnRef(agg2#2) * ResolvedArgumentRef(y)
//
// When resolving a query that calls an aggregate UDF, the query will
// have a ResolvedAggregateScan that invokes the UDF function.  The engine
// should remove the UDF aggregate function from the <aggregate_list>, and
// instead compute the additional aggregates from the
// UDF's <aggregate_expression_list>, and then add an additional Project
// to compute the final <function_expression>, which should produce the
// value for the original ResolvedAggregateScan's computed column for the
// UDF.  Some rewrites of the ResolvedColumn references inside the UDF will
// be required.  TODO If using ResolvedColumns makes this renaming
// too complicated, we could switch to use ResolvedArgumentRefs, or
// something new.
message ResolvedCreateFunctionStmtProto {
  optional ResolvedCreateStatementProto parent = 1;

  optional bool has_explicit_return_type = 13;
  optional TypeProto return_type = 3;
  repeated string argument_name_list = 11;
  optional FunctionSignatureProto signature = 10;
  optional bool is_aggregate = 8;
  optional string language = 4;
  optional string code = 5;
  repeated ResolvedComputedColumnProto aggregate_expression_list = 9;
  optional AnyResolvedExprProto function_expression = 6;
  repeated ResolvedOptionProto option_list = 7;
  optional ResolvedCreateStatementEnums.SqlSecurity sql_security = 12;
  optional ResolvedCreateStatementEnums.DeterminismLevel determinism_level = 14;
}

// This represents an argument definition, e.g. in a function's argument
// list.
//
// <name> is the name of the argument; optional for DROP FUNCTION statements.
// <type> is the type of the argument.
// <argument_kind> indicates what kind of argument this is, including scalar
//         vs aggregate.  NOT_AGGREGATE means this is a non-aggregate
//         argument in an aggregate function, which can only passed constant
//         values only.
//
// NOTE: Statements that create functions now include a FunctionSignature
// directly, and an argument_name_list if applicable.  These completely
// describe the function signature, so the ResolvedArgumentDef list can
// be considered unnecessary and deprecated.
// TODO We could remove this node in the future.
message ResolvedArgumentDefProto {
  optional ResolvedArgumentProto parent = 1;

  optional string name = 2;
  optional TypeProto type = 3;
  optional ResolvedArgumentDefEnums.ArgumentKind argument_kind = 4;
}

// This represents an argument reference, e.g. in a function's body.
// <name> is the name of the argument.
// <argument_kind> is the ArgumentKind from the ResolvedArgumentDef.
//         For scalar functions, this is always SCALAR.
//         For aggregate functions, it can be AGGREGATE or NOT_AGGREGATE.
//         If NOT_AGGREGATE, then this is a non-aggregate argument
//         to an aggregate function, which has one constant value
//         for the entire function call (over all rows in all groups).
//         (This is copied from the ResolvedArgumentDef for convenience.)
message ResolvedArgumentRefProto {
  optional ResolvedExprProto parent = 1;

  optional string name = 2;
  optional ResolvedArgumentDefEnums.ArgumentKind argument_kind = 3;
}

// This statement creates a user-defined table-valued function:
//   CREATE [TEMP] TABLE FUNCTION [IF NOT EXISTS]
//     <name_path> (<argument_name_list>)
//     [RETURNS <return_type>]
//     [OPTIONS (<option_list>)]
//     [LANGUAGE <language>]
//     [AS <code> | AS ( <query> )]
//
//   <argument_name_list> contains the names of the function arguments.
//   <signature> is the FunctionSignature of the created function, with all
//          options.  This can be used to create a Function to load into a
//          Catalog for future queries.
//   <option_list> has engine-specific directives for modifying functions.
//   <language> is the programming language used by the function. This field
//          is set to 'SQL' for SQL functions, to the language name specified
//          in the LANGUAGE clause if present, and to 'UNDECLARED' if both
//          the LANGUAGE clause and query are not present.
//   <code> is an optional string literal that contains the function
//          definition.  Some engines may allow this argument to be omitted
//          for certain types of external functions.  This will always be set
//          for SQL functions.
//   <query> is the SQL query invoked for the function.  This will be unset
//          for external language functions. For non-templated SQL functions,
//          this is a resolved representation of the query in <code>.
//   <output_column_list> is the list of resolved output
//          columns returned by the table-valued function.
//   <is_value_table> If true, this function returns a value table.
//          Rather than producing rows with named columns, it produces
//          rows with a single unnamed value type. <output_column_list> will
//          have exactly one anonymous column (with no name).
//          See (broken link).
//   <sql_security> is the declared security mode for the function. Values
//          include 'INVOKER', 'DEFINER'.
//
// ----------------------
// Table-Valued Functions
// ----------------------
//
// This is a statement to create a new table-valued function. Each
// table-valued function returns an entire table as output instead of a
// single scalar value. Table-valued functions can only be created if
// LanguageOptions has FEATURE_CREATE_TABLE_FUNCTION enabled.
//
// For SQL table-valued functions that include a defined SQL body, the
// <query> is non-NULL and contains the resolved SQL body.
// In this case, <output_column_list> contains a list of the
// output columns of the SQL body. The <query> uses
// ResolvedArgumentRefs to refer to scalar arguments and
// ResolvedRelationArgumentScans to refer to relation arguments.
//
// The table-valued function may include RETURNS TABLE<...> to explicitly
// specify a schema for the output table returned by the function. If the
// function declaration includes a SQL body, then the names and types of the
// output columns of the corresponding <query> will have been
// coerced to exactly match 1:1 with the names and types of the columns
// specified in the RETURNS TABLE<...> section.
//
// When resolving a query that calls a table-valued function, the query will
// have a ResolvedTVFScan that invokes the function.
//
// Value tables: If the function declaration includes a value-table
// parameter, this is written as an argument of type "TABLE" where the table
// contains a single anonymous column with a type but no name. In this case,
// calls to the function may pass a (regular or value) table with a single
// (named or unnamed) column for any of these parameters, and ZetaSQL
// accepts these arguments as long as the column type matches.
//
// Similarly, if the CREATE TABLE FUNCTION statement includes a "RETURNS
// TABLE" section with a single column with no name, then this defines a
// value-table return type. The function then returns a value table as long
// as the SQL body returns a single column whose type matches (independent of
// whether the SQL body result is a value table or not, and whether the
// returned column is named or unnamed).
//
// --------------------------------
// Templated Table-Valued Functions
// --------------------------------
//
// ZetaSQL supports table-valued function declarations with parameters of
// type ANY TABLE. This type indicates that any schema is valid for tables
// passed for this parameter. In this case:
//
// * the IsTemplated() method of the <signature> field returns true,
// * the <output_column_list> field is empty,
// * the <is_value_table> field is set to a default value of false (since
//   ZetaSQL cannot analyze the function body in the presence of templated
//   parameters, it is not possible to detect this property yet),
//
// TODO: Update this description once ZetaSQL supports more types
// of templated function parameters. Currently only ANY TABLE is supported.
message ResolvedCreateTableFunctionStmtProto {
  optional ResolvedCreateStatementProto parent = 1;

  repeated string argument_name_list = 2;
  optional FunctionSignatureProto signature = 3;
  repeated ResolvedOptionProto option_list = 4;
  optional string language = 5;
  optional string code = 6;
  optional AnyResolvedScanProto query = 7;
  repeated ResolvedOutputColumnProto output_column_list = 8;
  optional bool is_value_table = 9;
  optional ResolvedCreateStatementEnums.SqlSecurity sql_security = 10;
}

// This represents a relation argument reference in a table-valued function's
// body. The 'column_list' of this ResolvedScan includes column names from
// the relation argument in the table-valued function signature.
message ResolvedRelationArgumentScanProto {
  optional ResolvedScanProto parent = 1;

  // This is the name of the relation argument for the table-valued
  // function.  It is used to match this relation argument reference in
  // a TVF SQL function body with one of possibly several relation
  // arguments in the TVF call.
  optional string name = 2;
  // If true, the result of this query is a value table. Rather than
  // producing rows with named columns, it produces rows with a single
  // unnamed value type. See (broken link).
  optional bool is_value_table = 3;
}

// This statement: [ (<arg_list>) ];
//
// <arg_list> is an optional list of parameters.  If given, each parameter
//            may consist of a type, or a name and a type.
//
// NOTE: This can be considered deprecated in favor of the FunctionSignature
//       stored directly in the statement.
//
// NOTE: ResolvedArgumentList is not related to the ResolvedArgument class,
//       which just exists to organize node classes.
message ResolvedArgumentListProto {
  optional ResolvedArgumentProto parent = 1;

  repeated ResolvedArgumentDefProto arg_list = 2;
}

// This wrapper is used for an optional FunctionSignature.
message ResolvedFunctionSignatureHolderProto {
  optional ResolvedArgumentProto parent = 1;

  optional FunctionSignatureProto signature = 2;
}

// This statement: DROP FUNCTION [IF EXISTS] <name_path>
//   [ (<arguments>) ];
//
// <is_if_exists> silently ignore the "name_path does not exist" error.
// <name_path> is the identifier path of the function to be dropped.
// <arguments> is an optional list of parameters.  If given, each parameter
//            may consist of a type, or a name and a type.  The name is
//            disregarded, and is allowed to permit copy-paste from CREATE
//            FUNCTION statements.
// <signature> is the signature of the dropped function.  Argument names and
//            argument options are ignored because only the types matter
//            for matching signatures in DROP FUNCTION.  The return type
//            in this signature will always be <void>, since return type
//            is ignored when matching signatures for DROP.
//            TODO <arguments> could be deprecated in favor of this.
message ResolvedDropFunctionStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional bool is_if_exists = 2;
  repeated string name_path = 3;
  // NOTE: arguments for DROP FUNCTION statements are matched only on
  // type; names for any arguments in ResolvedArgumentList will be set
  // to the empty string irrespective of whether or not argument names
  // were given in the DROP FUNCTION statement.
  optional ResolvedArgumentListProto arguments = 4;
  // NOTE: arguments for DROP FUNCTION statements are matched only on
  // type; names are irrelevant, so no argument names are saved to use
  // with this signature.  Additionally, the return type will always be
  // <void>, since return types are ignored for DROP FUNCTION.
  optional ResolvedFunctionSignatureHolderProto signature = 5;
}

// This statement: CALL <procedure>;
//
// <procedure> Procedure to call.
// <signature> Resolved FunctionSignature for this procedure.
// <argument_list> Procedure arguments.
message ResolvedCallStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional ProcedureRefProto procedure = 2;
  optional FunctionSignatureProto signature = 3;
  repeated AnyResolvedExprProto argument_list = 4;
}

// This statement: IMPORT <import_kind>
//                              [<name_path> [AS|INTO <alias_path>]
//                              |<file_path>]
//                        [<option_list>];
//
// <import_kind> The type of the object, currently supports MODULE and PROTO.
// <name_path>   The identifier path of the object to import, e.g., foo.bar,
//               used in IMPORT MODULE statement.
// <file_path>   The file path of the object to import, e.g., "file.proto",
//               used in IMPORT PROTO statement.
// <alias_path>  The AS alias path for the object.
// <into_alias_path>  The INTO alias path for the object.
// <option_list> Engine-specific directives for the import.
//
// Either <name_path> or <file_path> will be populated but not both.
//       <name_path> will be populated for IMPORT MODULE.
//       <file_path> will be populated for IMPORT PROTO.
//
// At most one of <alias_path> or <into_alias_path> will be populated.
//       <alias_path> may be populated for IMPORT MODULE.
//       <into_alias_path> may be populated for IMPORT PROTO.
//
// IMPORT MODULE and IMPORT PROTO both support options.
//
// See (broken link) for more detail on IMPORT MODULE.
// See (broken link) for more detail on IMPORT PROTO.
message ResolvedImportStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional ResolvedImportStmtEnums.ImportKind import_kind = 2;
  repeated string name_path = 3;
  optional string file_path = 4;
  repeated string alias_path = 5;
  repeated string into_alias_path = 7;
  repeated ResolvedOptionProto option_list = 6;
}

// This statement: MODULE <name_path> [<option_list>];
//
// <name_path> is the identifier path of the module.
// <option_list> Engine-specific directives for the module statement.
//
// See (broken link) for more detail on MODULEs.
message ResolvedModuleStmtProto {
  optional ResolvedStatementProto parent = 1;

  repeated string name_path = 2;
  repeated ResolvedOptionProto option_list = 3;
}

// This represents a HAVING MAX or HAVING MIN modifier in an aggregate
// expression. If an aggregate has arguments (x HAVING {MAX/MIN} y),
// the aggregate will be computed over only the x values in the rows with the
// maximal/minimal values of y.
//
// <kind> the MAX/MIN kind of this HAVING
// <having_expr> the HAVING expression (y in the above example)
message ResolvedAggregateHavingModifierProto {
  optional ResolvedArgumentProto parent = 1;

  optional ResolvedAggregateHavingModifierEnums.HavingModifierKind kind = 2;
  optional AnyResolvedExprProto having_expr = 3;
}

// This statement:
//   CREATE MATERIALIZED VIEW <name> [PARTITION BY expr, ...]
//   [CLUSTER BY expr, ...] [OPTIONS (...)] AS SELECT ...
//
// <column_definition_list> matches 1:1 with the <output_column_list> in
// ResolvedCreateViewBase and provides explicit definition for each
// ResolvedColumn produced by <query>. Output column names and types must
// match column definition names and types. If the table is a value table,
// <column_definition_list> must have exactly one column, with a generated
// name such as "$struct".
//
// Currently <column_definition_list> contains the same schema information
// (column names and types) as <output_definition_list>, but when/if we
// allow specifying column OPTIONS as part of CMV statement, this information
// will be available only in <column_definition_list>. Therefore, consumers
// are encouraged to read from <column_definition_list> rather than from
// <output_column_list> to determine the schema, if possible.
//
// <partition_by_list> specifies the partitioning expressions for the
//                     materialized view.
// <cluster_by_list> specifies the clustering expressions for the
//                   materialized view.
message ResolvedCreateMaterializedViewStmtProto {
  optional ResolvedCreateViewBaseProto parent = 1;

  repeated ResolvedColumnDefinitionProto column_definition_list = 2;
  repeated AnyResolvedExprProto partition_by_list = 3;
  repeated AnyResolvedExprProto cluster_by_list = 4;
}

// This statement creates a user-defined procedure:
// CREATE [OR REPLACE] [TEMP] PROCEDURE [IF NOT EXISTS] <name_path>
// (<arg_list>) [OPTIONS (<option_list>)]
// BEGIN
// <procedure_body>
// END;
//
// <name_path> is the identifier path of the procedure.
// <argument_name_list> The names of the function arguments.
// <signature> is the FunctionSignature of the created procedure, with all
//        options.  This can be used to create a procedure to load into a
//        Catalog for future queries.
// <option_list> has engine-specific directives for modifying procedures.
// <procedure_body> is a string literal that contains the procedure body.
//        It includes everything from the BEGIN keyword to the END keyword,
//        inclusive.
//
//        The resolver will perform some basic validation on the procedure
//        body, for example, verifying that DECLARE statements are in the
//        proper position, and that variables are not declared more than
//        once, but any validation that requires the catalog (including
//        generating resolved tree nodes for individual statements) is
//        deferred until the procedure is actually called.  This deferral
//        makes it possible to define a procedure which references a table
//        or routine that does not yet exist, so long as the entity is
//        created before the procedure is called.
message ResolvedCreateProcedureStmtProto {
  optional ResolvedCreateStatementProto parent = 1;

  repeated string argument_name_list = 2;
  optional FunctionSignatureProto signature = 3;
  repeated ResolvedOptionProto option_list = 4;
  optional string procedure_body = 5;
}

// An argument for an EXECUTE IMMEDIATE's USING clause.
//
// <name> an optional name for this expression
// <expression> the expression's value
message ResolvedExecuteImmediateArgumentProto {
  optional ResolvedArgumentProto parent = 1;

  optional string name = 2;
  optional AnyResolvedExprProto expression = 3;
}

// An EXECUTE IMMEDIATE statement
// EXECUTE IMMEDIATE <sql> [<into_clause>] [<using_clause>]
//
// <sql> a string expression indicating a SQL statement to be dynamically
//   executed
// <into_identifier_list> the identifiers whose values should be set.
//   Identifiers should not be repeated in the list.
// <using_argument_list> a list of arguments to supply for dynamic SQL.
//    The arguments should either be all named or all unnamed, and
//    arguments should not be repeated in the list.
message ResolvedExecuteImmediateStmtProto {
  optional ResolvedStatementProto parent = 1;

  optional AnyResolvedExprProto sql = 2;
  repeated string into_identifier_list = 3;
  repeated ResolvedExecuteImmediateArgumentProto using_argument_list = 4;
}

// An assignment of a value to another value.
message ResolvedAssignmentStmtProto {
  optional ResolvedStatementProto parent = 1;

  // Target of the assignment.  Currently, this will be either ResolvedSystemVariable, or a chain of ResolveGetField operations around it.
  optional AnyResolvedExprProto target = 2;
  // Value to assign into the target.  This will always be the same type as the target.
  optional AnyResolvedExprProto expr = 3;
}

//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// resolved_node_kind.proto GENERATED FROM resolved_node_kind.proto.template
syntax = "proto2";

package zetasql;

option java_package = "com.google.zetasql";
option java_outer_classname = "ZetaSQLResolvedNodeKind";

// Enum for types of ResolvedNode classes.
// Generated as a separate file to avoid circular dependencies.
enum ResolvedNodeKind {
  RESOLVED_LITERAL = 3;
  RESOLVED_PARAMETER = 4;
  RESOLVED_EXPRESSION_COLUMN = 5;
  RESOLVED_COLUMN_REF = 6;
  RESOLVED_CONSTANT = 103;
  RESOLVED_SYSTEM_VARIABLE = 139;
  RESOLVED_FUNCTION_CALL = 8;
  RESOLVED_AGGREGATE_FUNCTION_CALL = 9;
  RESOLVED_ANALYTIC_FUNCTION_CALL = 10;
  RESOLVED_CAST = 11;
  RESOLVED_MAKE_STRUCT = 12;
  RESOLVED_MAKE_PROTO = 13;
  RESOLVED_MAKE_PROTO_FIELD = 14;
  RESOLVED_GET_STRUCT_FIELD = 15;
  RESOLVED_GET_PROTO_FIELD = 16;
  RESOLVED_REPLACE_FIELD_ITEM = 128;
  RESOLVED_REPLACE_FIELD = 129;
  RESOLVED_SUBQUERY_EXPR = 17;
  RESOLVED_MODEL = 109;
  RESOLVED_CONNECTION = 141;
  RESOLVED_SINGLE_ROW_SCAN = 19;
  RESOLVED_TABLE_SCAN = 20;
  RESOLVED_JOIN_SCAN = 21;
  RESOLVED_ARRAY_SCAN = 22;
  RESOLVED_COLUMN_HOLDER = 23;
  RESOLVED_FILTER_SCAN = 24;
  RESOLVED_GROUPING_SET = 93;
  RESOLVED_AGGREGATE_SCAN = 25;
  RESOLVED_SET_OPERATION_ITEM = 94;
  RESOLVED_SET_OPERATION_SCAN = 26;
  RESOLVED_ORDER_BY_SCAN = 27;
  RESOLVED_LIMIT_OFFSET_SCAN = 28;
  RESOLVED_WITH_REF_SCAN = 29;
  RESOLVED_ANALYTIC_SCAN = 30;
  RESOLVED_SAMPLE_SCAN = 31;
  RESOLVED_COMPUTED_COLUMN = 32;
  RESOLVED_ORDER_BY_ITEM = 33;
  RESOLVED_COLUMN_ANNOTATIONS = 104;
  RESOLVED_GENERATED_COLUMN_INFO = 105;
  RESOLVED_COLUMN_DEFINITION = 91;
  RESOLVED_PRIMARY_KEY = 92;
  RESOLVED_FOREIGN_KEY = 110;
  RESOLVED_CHECK_CONSTRAINT = 113;
  RESOLVED_OUTPUT_COLUMN = 34;
  RESOLVED_PROJECT_SCAN = 35;
  RESOLVED_TVFSCAN = 81;
  RESOLVED_TVFARGUMENT = 82;
  RESOLVED_EXPLAIN_STMT = 37;
  RESOLVED_QUERY_STMT = 38;
  RESOLVED_CREATE_DATABASE_STMT = 95;
  RESOLVED_INDEX_ITEM = 96;
  RESOLVED_UNNEST_ITEM = 126;
  RESOLVED_CREATE_INDEX_STMT = 97;
  RESOLVED_CREATE_TABLE_STMT = 90;
  RESOLVED_CREATE_TABLE_AS_SELECT_STMT = 40;
  RESOLVED_CREATE_MODEL_STMT = 107;
  RESOLVED_CREATE_VIEW_STMT = 41;
  RESOLVED_CREATE_EXTERNAL_TABLE_STMT = 42;
  RESOLVED_EXPORT_DATA_STMT = 43;
  RESOLVED_DEFINE_TABLE_STMT = 44;
  RESOLVED_DESCRIBE_STMT = 45;
  RESOLVED_SHOW_STMT = 46;
  RESOLVED_BEGIN_STMT = 47;
  RESOLVED_SET_TRANSACTION_STMT = 120;
  RESOLVED_COMMIT_STMT = 48;
  RESOLVED_ROLLBACK_STMT = 49;
  RESOLVED_START_BATCH_STMT = 122;
  RESOLVED_RUN_BATCH_STMT = 123;
  RESOLVED_ABORT_BATCH_STMT = 124;
  RESOLVED_DROP_STMT = 50;
  RESOLVED_DROP_MATERIALIZED_VIEW_STMT = 121;
  RESOLVED_WITH_SCAN = 51;
  RESOLVED_WITH_ENTRY = 52;
  RESOLVED_OPTION = 53;
  RESOLVED_WINDOW_PARTITIONING = 54;
  RESOLVED_WINDOW_ORDERING = 55;
  RESOLVED_WINDOW_FRAME = 56;
  RESOLVED_ANALYTIC_FUNCTION_GROUP = 57;
  RESOLVED_WINDOW_FRAME_EXPR = 58;
  RESOLVED_DMLVALUE = 59;
  RESOLVED_DMLDEFAULT = 60;
  RESOLVED_ASSERT_STMT = 98;
  RESOLVED_ASSERT_ROWS_MODIFIED = 61;
  RESOLVED_INSERT_ROW = 62;
  RESOLVED_INSERT_STMT = 63;
  RESOLVED_DELETE_STMT = 64;
  RESOLVED_UPDATE_ITEM = 65;
  RESOLVED_UPDATE_ARRAY_ITEM = 102;
  RESOLVED_UPDATE_STMT = 66;
  RESOLVED_MERGE_WHEN = 100;
  RESOLVED_MERGE_STMT = 101;
  RESOLVED_TRUNCATE_STMT = 133;
  RESOLVED_PRIVILEGE = 67;
  RESOLVED_GRANT_STMT = 69;
  RESOLVED_REVOKE_STMT = 70;
  RESOLVED_ALTER_DATABASE_STMT = 134;
  RESOLVED_ALTER_MATERIALIZED_VIEW_STMT = 127;
  RESOLVED_ALTER_TABLE_STMT = 115;
  RESOLVED_ALTER_VIEW_STMT = 118;
  RESOLVED_SET_OPTIONS_ACTION = 117;
  RESOLVED_ADD_COLUMN_ACTION = 131;
  RESOLVED_DROP_COLUMN_ACTION = 132;
  RESOLVED_ALTER_TABLE_SET_OPTIONS_STMT = 71;
  RESOLVED_RENAME_STMT = 72;
  RESOLVED_CREATE_ROW_ACCESS_POLICY_STMT = 73;
  RESOLVED_DROP_ROW_ACCESS_POLICY_STMT = 74;
  RESOLVED_GRANT_TO_ACTION = 135;
  RESOLVED_FILTER_USING_ACTION = 136;
  RESOLVED_REVOKE_FROM_ACTION = 137;
  RESOLVED_RENAME_TO_ACTION = 138;
  RESOLVED_ALTER_ROW_ACCESS_POLICY_STMT = 75;
  RESOLVED_CREATE_CONSTANT_STMT = 99;
  RESOLVED_CREATE_FUNCTION_STMT = 76;
  RESOLVED_ARGUMENT_DEF = 77;
  RESOLVED_ARGUMENT_REF = 78;
  RESOLVED_CREATE_TABLE_FUNCTION_STMT = 88;
  RESOLVED_RELATION_ARGUMENT_SCAN = 89;
  RESOLVED_ARGUMENT_LIST = 79;
  RESOLVED_FUNCTION_SIGNATURE_HOLDER = 84;
  RESOLVED_DROP_FUNCTION_STMT = 80;
  RESOLVED_CALL_STMT = 83;
  RESOLVED_IMPORT_STMT = 86;
  RESOLVED_MODULE_STMT = 87;
  RESOLVED_AGGREGATE_HAVING_MODIFIER = 85;
  RESOLVED_CREATE_MATERIALIZED_VIEW_STMT = 119;
  RESOLVED_CREATE_PROCEDURE_STMT = 125;
  RESOLVED_EXECUTE_IMMEDIATE_ARGUMENT = 143;
  RESOLVED_EXECUTE_IMMEDIATE_STMT = 140;
  RESOLVED_ASSIGNMENT_STMT = 142;
  // User code that switches on this enum must have a default case so
  // builds won't break if new enums get added.
  __ResolvedNodeKind__switch_must_have_default__ = -1;
}//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

syntax = "proto2";

package zetasql.local_service;

import "google/protobuf/empty.proto";
import "google/protobuf/descriptor.proto";
import "zetasql/proto/function.proto";
import "zetasql/proto/options.proto";
import "zetasql/proto/simple_catalog.proto";
import "zetasql/public/options.proto";
import "zetasql/public/parse_resume_location.proto";
import "zetasql/public/simple_table.proto";
import "zetasql/public/type.proto";
import "zetasql/public/value.proto";
import "zetasql/resolved_ast/resolved_ast.proto";

option java_package = "com.google.zetasql";
option java_outer_classname = "LocalService";

// Note that *all* service RPCs are locked down to only be authorized by
// the user that started the ZetaSql service.  This disallows random users
// from sending requests to this service to be executed on behalf of the
// user that started the service.  Given that this service does not currently
// provide access to external data, this lockdown is precautionary and
// conservative.  But the lockdown will be necessary once the reference
// implementation is extended to execute full queries over external data,
// since we cannot allow random users to run queries over data accessible by
// the (different) user that started the ZetaSql service.
service ZetaSqlLocalService {
  // Prepare the sql expression in PrepareRequest with given columns and
  // parameters with zetasql::PreparedExpression and return the result
  // type as PrepareResponse. The prepared expression will be kept at server
  // side which can be referred to with the returned id.
  rpc Prepare(PrepareRequest) returns (PrepareResponse) {
  }
  // Evaluate the prepared expression in EvaluateRequest with given columns and
  // parameters with zetasql::PreparedExpression and return the result
  // and value as EvaluateResponse.
  rpc Evaluate(EvaluateRequest) returns (EvaluateResponse) {
  }
  // Cleanup the prepared expression kept at server side with given id.
  rpc Unprepare(UnprepareRequest) returns (google.protobuf.Empty) {
  }
  // Get a table schema from a proto.
  rpc GetTableFromProto(TableFromProtoRequest) returns (SimpleTableProto) {
  }
  // Register a catalog at server side so that it can be reused.
  rpc RegisterCatalog(RegisterCatalogRequest) returns (RegisterResponse) {
  }
  // Register a parse resume location
  rpc RegisterParseResumeLocation(ParseResumeLocationProto)
      returns (RegisterResponse) {
  }
  // Analyze a SQL statement, return the resolved AST and an optional byte
  // position if end of input is not yet reached.
  rpc Analyze(AnalyzeRequest) returns (AnalyzeResponse) {
  }
  // Build a SQL statement or expression from a resolved AST.
  rpc BuildSql(BuildSqlRequest) returns (BuildSqlResponse) {
  }
  // Validate statement and extract table names.
  rpc ExtractTableNamesFromStatement(ExtractTableNamesFromStatementRequest)
      returns (ExtractTableNamesFromStatementResponse) {
  }

  // Validate statement, return table names and a byte offset of the next
  // statement.
  //
  // Statements are separated by semicolons. A final semicolon is not required
  // on the last statement. Whitespace between statements is ignored. Whitespace
  // after that last semicolon is treated as a separate empty statement and
  // would cause a parse error.
  //
  // Full text passed to this method does not need to be syntactically valid;
  // only the current statement pointed by parse_resume_location should be
  // parseable.
  //
  // Passing incorrect parse_resume_position (negative or pointing outside
  // input data) would result in a generic::internal error.
  //
  // If language options are not provided, the parser would use a default
  // LanguageOptions object. Refer to the LanguageOptions class definition
  // for the exact implementation details.
  //
  // Client can detect that there's no more SQL statements to parse
  // by comparing this byte offset to the overall input length
  // (similar to Analyze method)
  //
  // After a parse error, parse_resume_location is not available; it's up
  // to client to try and recover from parse errors.
  //
  // Unsupported statements (e.g. SET statements from F1 dialect) are treated
  // as parse errors.
  //
  // Note: statements are handled by ParseNextStatement function.
  // Documentation on that function is the source of truth on the behavior.
  //
  rpc ExtractTableNamesFromNextStatement(
      ExtractTableNamesFromNextStatementRequest)
      returns (ExtractTableNamesFromNextStatementResponse) {
  }
  // Format a SQL statement (see also (broken link))
  rpc FormatSql(FormatSqlRequest) returns (FormatSqlResponse) {
  }
  // Format a SQL statement using the new lenient_formatter.h
  rpc LenientFormatSql(FormatSqlRequest) returns (FormatSqlResponse) {
  }
  // Cleanup a registered catalog.
  rpc UnregisterCatalog(UnregisterRequest) returns (google.protobuf.Empty) {
  }
  // Cleanup a registered parse resume location.
  rpc UnregisterParseResumeLocation(UnregisterRequest)
      returns (google.protobuf.Empty) {
  }
  // Get ZetaSQL builtin functions specified by given options.
  rpc GetBuiltinFunctions(ZetaSQLBuiltinFunctionOptionsProto)
      returns (GetBuiltinFunctionsResponse) {
  }
  // Add SimpleTable
  rpc AddSimpleTable(AddSimpleTableRequest) returns (google.protobuf.Empty) {
  }
  // Gets ZetaSQL lanauge options.
  rpc GetLanguageOptions(LanguageOptionsRequest)
      returns (LanguageOptionsProto) {
  }
}

message PrepareRequest {
  optional string sql = 1;
  optional AnalyzerOptionsProto options = 2;
  // Serialized descriptor pools of all types in the request.
  repeated google.protobuf.FileDescriptorSet file_descriptor_set = 3;
  optional SimpleCatalogProto simple_catalog = 4;
  optional int64 registered_catalog_id = 5;
}

message PrepareResponse {
  optional int64 prepared_expression_id = 1;
  optional TypeProto output_type = 2;
  // No file_descriptor_set returned. Use the same descriptor pools as sent in
  // the request deserialize the type.
}

message EvaluateRequest {
  optional string sql = 1;

  message Parameter {
    optional string name = 1;
    optional ValueProto value = 2;
    optional TypeProto type = 3;
  }

  repeated Parameter columns = 2;
  repeated Parameter params = 3;
  // Serialized descriptor pools of all types in the request.
  repeated google.protobuf.FileDescriptorSet file_descriptor_set = 4;
  // Set if the expression is already prepared, in which case sql and
  // file_descriptor_set will be ignored.
  optional int64 prepared_expression_id = 5;
}

message EvaluateResponse {
  optional ValueProto value = 1;
  optional TypeProto type = 2;
  optional int64 prepared_expression_id = 3;
}

message UnprepareRequest {
  optional int64 prepared_expression_id = 1;
}

message TableFromProtoRequest {
  optional ProtoTypeProto proto = 1;
  optional google.protobuf.FileDescriptorSet file_descriptor_set = 2;
}

message RegisteredParseResumeLocationProto {
  optional int64 registered_id = 1;
  optional int32 byte_position = 2;
}

message AnalyzeRequest {
  optional AnalyzerOptionsProto options = 1;
  optional SimpleCatalogProto simple_catalog = 2;
  repeated google.protobuf.FileDescriptorSet file_descriptor_set = 3;
  // Set if using a registered catalog, in which case simple_catalog and
  // file_descriptor_set will be ignored.
  optional int64 registered_catalog_id = 4;

  oneof target {
    // Single statement.
    string sql_statement = 5;
    // Multiple statement.
    ParseResumeLocationProto parse_resume_location = 6;
    // Set if using a registered parse resume location.
    RegisteredParseResumeLocationProto registered_parse_resume_location = 7;
    // Expression.
    string sql_expression = 8;
  }
}

message AnalyzeResponse {
  oneof result {
    AnyResolvedStatementProto resolved_statement = 1;
    AnyResolvedExprProto resolved_expression = 3;
  }
  // Set only if the request had parse_resume_location.
  optional int32 resume_byte_position = 2;
}

message BuildSqlRequest {
  optional SimpleCatalogProto simple_catalog = 1;
  repeated google.protobuf.FileDescriptorSet file_descriptor_set = 2;
  // Set if using a registered catalog, in which case simple_catalog and
  // file_descriptor_set will be ignored.
  optional int64 registered_catalog_id = 3;

  oneof target {
    AnyResolvedStatementProto resolved_statement = 4;
    AnyResolvedExprProto resolved_expression = 5;
  }
}

message BuildSqlResponse {
  optional string sql = 1;
}

message ExtractTableNamesFromStatementRequest {
  optional string sql_statement = 1;
}

message ExtractTableNamesFromStatementResponse {
  repeated TableName table_name = 1;

  message TableName {
    repeated string table_name_segment = 1;
  }
}

message ExtractTableNamesFromNextStatementRequest {
  required ParseResumeLocationProto parse_resume_location = 1;

  // If language options are not provided, the parser would use a default
  // LanguageOptions object. Refer to the LanguageOptions class definition
  // for the exact implementation details.
  //
  // Note that There may be untrivial differences between providing an empty
  // options/ field and not providing one which depending on the
  // LanguageOptions implementation details.
  //
  // The current implementation of the LanguageOptions class has default value
  // of supported_statement_kinds set to {RESOLVED_QUERY_STMT}. This means that
  // if you don't provide any options, then you're limited to this one
  // kind of statement. If you provide an empty options proto, you're
  // explicitly setting supported_statement_kinds to an empty set,
  // allowing all types of statements.
  //
  // See LanguageOptions::SupportsStatementKind and
  // LanguageOptions::supported_statement_kinds_ definitions for the source of
  // truth on this example.
  optional LanguageOptionsProto options = 2;
}

message ExtractTableNamesFromNextStatementResponse {
  message TableName {
    repeated string table_name_segment = 1;
  }

  repeated TableName table_name = 1;
  optional int32 resume_byte_position = 2;
}

message FormatSqlRequest {
  optional string sql = 1;
}

message FormatSqlResponse {
  optional string sql = 1;
}

message RegisterCatalogRequest {
  optional SimpleCatalogProto simple_catalog = 1;
  repeated google.protobuf.FileDescriptorSet file_descriptor_set = 2;
}

message RegisterResponse {
  optional int64 registered_id = 1;
}

message UnregisterRequest {
  optional int64 registered_id = 1;
}

message GetBuiltinFunctionsResponse {
  repeated FunctionProto function = 1;
  // No file_descriptor_set returned. For now, only Datetime functions
  // have arguments of enum type which need to be added manually when
  // deserializing.
}

message AddSimpleTableRequest {
  optional int64 registered_catalog_id = 1;
  optional SimpleTableProto table = 2;
  repeated google.protobuf.FileDescriptorSet file_descriptor_set = 3;
}

message LanguageOptionsRequest {
  optional bool maximum_features = 1;
  optional LanguageVersion language_version = 2;
}
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

syntax = "proto2";

package zetasql;

option java_package = "com.google.zetasql";
option java_outer_classname = "FunctionProtos";

// Public enum and message definitions.
import "zetasql/public/deprecation_warning.proto";
import "zetasql/public/function.proto";
import "zetasql/public/options.proto";
import "zetasql/public/parse_location_range.proto";
import "zetasql/public/parse_resume_location.proto";
import "zetasql/public/type.proto";
import "zetasql/resolved_ast/serialization.proto";

// Wire format of Function related messages, these shouldn't be exposed to end
// users normally.

message TVFRelationColumnProto {
  optional string name = 1;
  optional TypeProto type = 2;
  optional bool is_pseudo_column = 3;
  // Store the parse location ranges for column name and type.
  optional ParseLocationRangeProto name_parse_location_range = 4;
  optional ParseLocationRangeProto type_parse_location_range = 5;
}

message TVFRelationProto {
  repeated TVFRelationColumnProto column = 1;
  optional bool is_value_table = 2 [default = false];
}

message TVFModelProto {
  optional string name = 1;
  optional string full_name = 2;
}

message TVFConnectionProto {
  optional string name = 1;
  optional string full_name = 2;
}

// The fields in here are in FunctionArgumentTypeOptions in the c++ API.
message FunctionArgumentTypeOptionsProto {
  optional FunctionEnums.ArgumentCardinality cardinality = 1;
  optional bool must_be_constant = 2;
  optional bool must_be_non_null = 3;
  optional bool is_not_aggregate = 4;
  optional bool must_support_equality = 5;
  optional bool must_support_ordering = 6;
  optional int64 min_value = 7;
  optional int64 max_value = 8;
  optional bool extra_relation_input_columns_allowed = 9;
  optional TVFRelationProto relation_input_schema = 10;
  optional string argument_name = 11;
  optional ParseLocationRangeProto argument_name_parse_location = 12;
  optional ParseLocationRangeProto argument_type_parse_location = 13;
  optional FunctionEnums.ProcedureArgumentMode procedure_argument_mode = 14;
  optional bool argument_name_is_mandatory = 15 [default = false];
}

message FunctionArgumentTypeProto {
  optional SignatureArgumentKind kind = 1;
  optional TypeProto type = 2;
  optional int32 num_occurrences = 4;

  optional FunctionArgumentTypeOptionsProto options = 3;
}

message FunctionSignatureOptionsProto {
  // optional uint64 timestamp_modes = 1;  bitset<TimestampMode>
  optional bool is_deprecated = 2 [default = false];
  repeated FreestandingDeprecationWarning additional_deprecation_warning = 3;
}

message FunctionSignatureProto {
  repeated FunctionArgumentTypeProto argument = 1;
  optional FunctionArgumentTypeProto return_type = 2;
  optional int64 context_id = 3;
  optional FunctionSignatureOptionsProto options = 4;
}

message FunctionOptionsProto {
  optional bool supports_over_clause = 1 [default = false];
  optional FunctionEnums.WindowOrderSupport window_ordering_support = 2
      [default = ORDER_UNSUPPORTED];
  optional bool supports_window_framing = 3 [default = false];
  optional bool arguments_are_coercible = 4 [default = true];
  optional bool is_deprecated = 5 [default = false];
  optional string alias_name = 6;
  optional string sql_name = 7;
  optional bool allow_external_usage = 8 [default = true];
  optional FunctionEnums.Volatility volatility = 9 [default = IMMUTABLE];
  optional bool supports_order_by = 10 [default = false];
  repeated LanguageFeature required_language_feature = 11;
  optional bool supports_limit = 12 [default = false];
  optional bool supports_null_handling_modifier = 13 [default = false];
  optional bool supports_safe_error_mode = 14 [default = true];
  optional bool supports_having_modifier = 15 [default = true];
  optional bool uses_upper_case_sql_name = 17 [default = true];
}

message FunctionProto {
  repeated string name_path = 1;
  optional string group = 2;
  optional FunctionEnums.Mode mode = 3;
  repeated FunctionSignatureProto signature = 4;
  optional FunctionOptionsProto options = 5;
  optional ParseResumeLocationProto parse_resume_location = 8;
  repeated string templated_sql_function_argument_name = 7;
}

message ResolvedFunctionCallInfoProto {
  // Nothing in here for now.
  // TODO: add extra fields in here for derived context objects.
}

message TableValuedFunctionProto {
  repeated string name_path = 1;
  optional FunctionSignatureProto signature = 2;
  optional FunctionEnums.TableValuedFunctionType type = 3;
  optional FunctionEnums.Volatility volatility = 8;
  optional ParseResumeLocationProto parse_resume_location = 6;
  repeated string argument_name = 5;
  optional string custom_context = 7;
}

message TVFArgumentProto {
  optional ValueWithTypeProto scalar_argument = 1;
  optional TVFRelationProto relation_argument = 2;
  optional TVFModelProto model_argument = 3;
  optional TVFConnectionProto connection_argument = 4;
}

message TVFSignatureOptionsProto {
  repeated FreestandingDeprecationWarning additional_deprecation_warning = 1;
}

message TVFSignatureProto {
  repeated TVFArgumentProto argument = 1;
  optional TVFRelationProto output_schema = 2;
  optional TVFSignatureOptionsProto options = 3;
}

message ProcedureProto {
  repeated string name_path = 1;
  optional FunctionSignatureProto signature = 2;
}
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

syntax = "proto2";

package zetasql;

option java_package = "com.google.zetasql";
option java_outer_classname = "InternalErrorLocationProtos";

import "zetasql/public/error_location.proto";

// Serialized form of ParseLocationPoint, only to be used inside the
// ZetaSQL library to attach an error location in internal form to a
// util::Status. This should never leave the library: externally we should
// attach an ErrorLocation proto.
message InternalErrorLocation {
  optional int32 byte_offset = 3;

  optional string filename = 4;

  // An optional list of error source information for the related Status.
  // The last element in this list is the immediate error cause, with
  // the previous element being its cause, etc.
  repeated ErrorSource error_source = 5;
}
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

syntax = "proto2";

package zetasql;

import "zetasql/public/builtin_function.proto";
import "zetasql/public/options.proto";
import "zetasql/public/type.proto";
import "zetasql/resolved_ast/resolved_node_kind.proto";

option java_package = "com.google.zetasql";
option java_outer_classname = "ZetaSQLOptionsProto";

// Specify what built-in functions should be load.
// Used for getting built-in functions through local server.
message ZetaSQLBuiltinFunctionOptionsProto {
  optional LanguageOptionsProto language_options = 1;
  repeated FunctionSignatureId include_function_ids = 2;
  repeated FunctionSignatureId exclude_function_ids = 3;
}

// Serialized form of LanguageOptions.
message LanguageOptionsProto {
  reserved 1;  // optional TimestampMode timestamp_mode = 1;
  optional NameResolutionMode name_resolution_mode = 2;
  optional ProductMode product_mode = 3;
  optional bool error_on_deprecated_syntax = 4;
  repeated LanguageFeature enabled_language_features = 5;
  repeated ResolvedNodeKind supported_statement_kinds = 6;
}

// Serialized form of AllowedHintsAndOptions.
message AllowedHintsAndOptionsProto {
  message HintProto {
    optional string qualifier = 1;
    optional string name = 2;
    optional TypeProto type = 3;
    optional bool allow_unqualified = 4;
  }
  message OptionProto {
    optional string name = 1;
    optional TypeProto type = 2;
  }

  optional bool disallow_unknown_options = 1;
  repeated string disallow_unknown_hints_with_qualifier = 2;
  repeated HintProto hint = 3;
  repeated OptionProto option = 4;
}

// Serialized form of AnalyzerOptions.
// next id: 19
message AnalyzerOptionsProto {
  message QueryParameterProto {
    optional string name = 1;
    optional TypeProto type = 2;
  }

  message SystemVariableProto {
    repeated string name_path = 1;
    optional TypeProto type = 2;
  }

  optional LanguageOptionsProto language_options = 1;
  repeated QueryParameterProto query_parameters = 2;
  repeated TypeProto positional_query_parameters = 12;
  repeated QueryParameterProto expression_columns = 3;
  optional QueryParameterProto in_scope_expression_column = 4;
  repeated QueryParameterProto ddl_pseudo_columns = 15;
  // base::SequenceNumber does not support getting and setting the current
  // value, so it is not serializable. Reserving tag number 5 in case we want
  // to support it in some other way later.
  optional ErrorMessageMode error_message_mode = 6;
  // In the form that can be parsed by C++ absl::LoadTimeZone().
  optional string default_timezone = 7;
  optional bool record_parse_locations = 8;
  optional bool prune_unused_columns = 9;
  optional bool allow_undeclared_parameters = 10;
  optional ParameterMode parameter_mode = 13;
  optional AllowedHintsAndOptionsProto allowed_hints_and_options = 11;
  optional StatementContext statement_context = 14;
  reserved 16;  // optional bool strict_validation_on_column_replacements = 16;
  optional bool preserve_column_aliases = 17;
  repeated SystemVariableProto system_variables = 18;
}
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

syntax = "proto2";

package zetasql;

import "zetasql/proto/function.proto";
import "zetasql/proto/options.proto";
import "zetasql/public/simple_constant.proto";
import "zetasql/public/simple_table.proto";
import "zetasql/public/type.proto";

option java_package = "com.google.zetasql";
option java_outer_classname = "SimpleCatalogProtos";

message SimpleCatalogProto {
  message NamedTypeProto {
    optional string name = 1;
    optional TypeProto type = 2;
  }

  optional string name = 1;
  repeated SimpleTableProto table = 2;
  repeated NamedTypeProto named_type = 3;
  repeated SimpleCatalogProto catalog = 4;
  // Specify built-in functions to load.
  optional ZetaSQLBuiltinFunctionOptionsProto builtin_function_options = 5;
  repeated FunctionProto custom_function = 6;
  repeated TableValuedFunctionProto custom_tvf = 9;
  // The index of the FileDescriptorSet in the top-level request proto.
  // If set, SimpleCatalog::SetDescriptorPool will be called with the
  // DescriptorPool deserialized from the referred FileDescriptorSet.
  optional int32 file_descriptor_set_index = 7 [default = -1];
  repeated ProcedureProto procedure = 8;
  repeated SimpleConstantProto constant = 10;
}
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// LINT: LEGACY_NAMES

syntax = "proto2";

package zetasql;

option java_package = "com.google.zetasql";
option java_outer_classname = "ZetaSQLFunction";

// A unique ID for ZetaSQL function signatures.  Resolved ZetaSQL functions
// will provide one of these enums, and ZetaSQL implementations should map
// them to something they can evaluate.
enum FunctionSignatureId {
  // User code that switches on this enum must have a default case so
  // builds won't break if new enums get added.
  __FunctionSignatureId__switch_must_have_a_default__ = -1;

  FN_INVALID_FUNCTION_ID = 1;

  // The first set of functions do not use standard function call syntax,
  // reflecting operators, functions with infix notation (LIKE), and
  // other special functions (CASE).  FunctionSignatureIds are assigned
  // in ranges:
  //
  // 0002-0999 Non-standard function calls   (NextId: 261)
  // 1000-1099 String functions              (NextId: 1065)
  // 1100-1199 Control flow functions        (NextId: 1104)
  // 1200-1299 Time functions                (Fully used)
  // 1300-1399 Math functions                (NextId: 1388)
  // 1400-1499 Aggregate functions           (NextId: 1478)
  // 1500-1599 Analytic functions            (NextId: 1513)
  // 1600-1699 Misc functions                (NextId: 1682)
  // 1700-1799 Net functions                 (NextId: 1716)
  // 1800-1899 More time functions           (NextId: 1833)
  // 1900-1999 Hashing/encryption functions  (NextId: 1924)
  // 2000-2199 Geography functions           (NextId: 2063)

  // enum value                       // Related function name
  // ----------                       // ---------------------
  FN_ADD_DOUBLE = 2;                       // $add
  FN_ADD_INT64 = 4;                        // $add
  FN_ADD_UINT64 = 119;                     // $add
  FN_ADD_NUMERIC = 248;                    // $add
  FN_AND = 5;                              // $and
  FN_CASE_NO_VALUE = 6;                    // $case_no_value
  FN_CASE_WITH_VALUE = 7;                  // $case_with_value
  FN_DIVIDE_DOUBLE = 40;                   // $divide
  FN_DIVIDE_NUMERIC = 250;                 // $divide
  FN_GREATER = 107;                        // $greater
  FN_GREATER_INT64_UINT64 = 222;           // $greater
  FN_GREATER_UINT64_INT64 = 223;           // $greater
  FN_GREATER_OR_EQUAL = 108;               // $greater_or_equal
  FN_GREATER_OR_EQUAL_INT64_UINT64 = 224;  // $greater_or_equal
  FN_GREATER_OR_EQUAL_UINT64_INT64 = 225;  // $greater_or_equal
  FN_LESS = 105;                           // $less
  FN_LESS_INT64_UINT64 = 226;              // $less
  FN_LESS_UINT64_INT64 = 227;              // $less
  FN_LESS_OR_EQUAL = 106;                  // $less_or_equal
  FN_LESS_OR_EQUAL_INT64_UINT64 = 228;     // $less_or_equal
  FN_LESS_OR_EQUAL_UINT64_INT64 = 229;     // $less_or_equal
  FN_EQUAL = 42;                           // $equal
  FN_EQUAL_INT64_UINT64 = 230;             // $equal
  FN_EQUAL_UINT64_INT64 = 231;             // $equal
  FN_STRING_LIKE = 97;                     // $like
  FN_BYTE_LIKE = 98;                       // $like
  FN_IN = 100;                             // $in
  FN_IN_ARRAY = 219;                       // $in_array
  FN_BETWEEN = 110;                        // $between
  FN_BETWEEN_INT64_UINT64_UINT64 = 254;    // $between
  FN_BETWEEN_INT64_UINT64_INT64 = 255;     // $between
  FN_BETWEEN_INT64_INT64_UINT64 = 256;     // $between
  FN_BETWEEN_UINT64_INT64_INT64 = 257;     // $between
  FN_BETWEEN_UINT64_UINT64_INT64 = 258;    // $between
  FN_BETWEEN_UINT64_INT64_UINT64 = 259;    // $between
  FN_IS_NULL = 101;                        // $is_null
  FN_IS_TRUE = 102;                        // $is_true
  FN_IS_FALSE = 103;                       // $is_false
  FN_MULTIPLY_DOUBLE = 41;                 // $multiply
  FN_MULTIPLY_INT64 = 44;                  // $multiply
  FN_MULTIPLY_UINT64 = 114;                // $multiply
  FN_MULTIPLY_NUMERIC = 251;               // $multiply
  FN_NOT = 45;                             // $not
  FN_NOT_EQUAL = 109;                      // $not_equal
  FN_NOT_EQUAL_INT64_UINT64 = 232;         // $not_equal
  FN_NOT_EQUAL_UINT64_INT64 = 233;         // $not_equal
  FN_OR = 46;                              // $or
  FN_SUBTRACT_DOUBLE = 115;                // $subtract
  FN_SUBTRACT_INT64 = 48;                  // $subtract
  FN_SUBTRACT_UINT64 = 117;                // $subtract
  FN_SUBTRACT_NUMERIC = 249;               // $subtract

  FN_UNARY_MINUS_INT32 = 83;     // $unary_minus
  FN_UNARY_MINUS_INT64 = 84;     // $unary_minus
  FN_UNARY_MINUS_FLOAT = 87;     // $unary_minus
  FN_UNARY_MINUS_DOUBLE = 88;    // $unary_minus
  FN_UNARY_MINUS_NUMERIC = 252;  // $unary_minus

  // Bitwise unary operators.
  FN_BITWISE_NOT_INT32 = 120;   // $bitwise_not
  FN_BITWISE_NOT_INT64 = 121;   // $bitwise_not
  FN_BITWISE_NOT_UINT32 = 122;  // $bitwise_not
  FN_BITWISE_NOT_UINT64 = 123;  // $bitwise_not
  FN_BITWISE_NOT_BYTES = 241;   // $bitwise_not
  // Bitwise binary operators.
  FN_BITWISE_OR_INT32 = 124;    // $bitwise_or
  FN_BITWISE_OR_INT64 = 125;    // $bitwise_or
  FN_BITWISE_OR_UINT32 = 126;   // $bitwise_or
  FN_BITWISE_OR_UINT64 = 127;   // $bitwise_or
  FN_BITWISE_OR_BYTES = 242;    // $bitwise_or
  FN_BITWISE_XOR_INT32 = 128;   // $bitwise_xor
  FN_BITWISE_XOR_INT64 = 129;   // $bitwise_xor
  FN_BITWISE_XOR_UINT32 = 130;  // $bitwise_xor
  FN_BITWISE_XOR_UINT64 = 131;  // $bitwise_xor
  FN_BITWISE_XOR_BYTES = 243;   // $bitwise_xor
  FN_BITWISE_AND_INT32 = 132;   // $bitwise_and
  FN_BITWISE_AND_INT64 = 133;   // $bitwise_and
  FN_BITWISE_AND_UINT32 = 134;  // $bitwise_and
  FN_BITWISE_AND_UINT64 = 135;  // $bitwise_and
  FN_BITWISE_AND_BYTES = 244;   // $bitwise_and
  // For all bitwise shift operators, the second argument has int64 type.
  // Expected behavior of bitwise shift operations:
  // * Shifting by a negative offset is an error.
  // * Shifting by >= 64 for uint64/int64 and >= 32 for int32/uint32 gives 0.
  // * Shifting right on signed values does not do sign extension.
  FN_BITWISE_LEFT_SHIFT_INT32 = 136;    // $bitwise_left_shift
  FN_BITWISE_LEFT_SHIFT_INT64 = 137;    // $bitwise_left_shift
  FN_BITWISE_LEFT_SHIFT_UINT32 = 138;   // $bitwise_left_shift
  FN_BITWISE_LEFT_SHIFT_UINT64 = 139;   // $bitwise_left_shift
  FN_BITWISE_LEFT_SHIFT_BYTES = 245;    // $bitwise_left_shift
  FN_BITWISE_RIGHT_SHIFT_INT32 = 140;   // $bitwise_right_shift
  FN_BITWISE_RIGHT_SHIFT_INT64 = 141;   // $bitwise_right_shift
  FN_BITWISE_RIGHT_SHIFT_UINT32 = 142;  // $bitwise_right_shift
  FN_BITWISE_RIGHT_SHIFT_UINT64 = 143;  // $bitwise_right_shift
  FN_BITWISE_RIGHT_SHIFT_BYTES = 246;   // $bitwise_right_shift

  // BIT_COUNT functions.
  FN_BIT_COUNT_INT32 = 144;   // bit_count(int32) -> int64
  FN_BIT_COUNT_INT64 = 145;   // bit_count(int64) -> int64
  FN_BIT_COUNT_UINT64 = 146;  // bit_count(uint64) -> int64
  FN_BIT_COUNT_BYTES = 247;   // bit_count(bytes) -> int64

  // TODO: Need to assign these proper ids since they have
  // standard function call syntax.
  FN_ARRAY_LENGTH = 220;           // array_length(array) -> int64
  FN_MAKE_ARRAY = 218;             // $make_array
  FN_ARRAY_AT_OFFSET = 234;        // $array_at_offset
  FN_ARRAY_AT_ORDINAL = 235;       // $array_at_ordinal
  FN_SAFE_ARRAY_AT_OFFSET = 239;   // $safe_array_at_offset
  FN_SAFE_ARRAY_AT_ORDINAL = 240;  // $safe_array_at_ordinal
  FN_ARRAY_CONCAT = 236;           // array_concat(repeated array) -> array
  FN_ARRAY_CONCAT_OP = 260;        // array_concat(array, array) -> array
  // array_to_string(array, string[, string]) -> string
  FN_ARRAY_TO_STRING = 237;
  // array_to_string(array, bytes[, bytes]) -> bytes
  FN_ARRAY_TO_BYTES = 238;

  FN_ERROR = 253;  // error(string) -> {unused result, coercible to any type}

  FN_COUNT_STAR = 57;  // $count_star

  // The following functions use standard function call syntax.
  // TODO: We may want to move all of these into another ID space
  // separating them from true built-in functions declared above.

  // String functions
  FN_CONCAT_STRING = 1000;          // concat(repeated string) -> string
  FN_CONCAT_BYTES = 1001;           // concat(repeated bytes) -> bytes
  FN_CONCAT_OP_STRING = 1063;       // concat(string, string) -> string
  FN_CONCAT_OP_BYTES = 1064;        // concat(bytes, bytes) -> bytes
  FN_STRPOS_STRING = 1002;          // strpos(string, string) -> string
  FN_STRPOS_BYTES = 1003;           // strpos(bytes, bytes) -> bytes
  FN_LOWER_STRING = 1006;           // lower(string) -> string
  FN_LOWER_BYTES = 1007;            // lower(bytes) -> bytes
  FN_UPPER_STRING = 1008;           // upper(string) -> string
  FN_UPPER_BYTES = 1009;            // upper(bytes) -> bytes
  FN_LENGTH_STRING = 1010;          // length(string) -> int64
  FN_LENGTH_BYTES = 1011;           // length(bytes) -> int64
  FN_STARTS_WITH_STRING = 1012;     // starts_with(string, string) -> string
  FN_STARTS_WITH_BYTES = 1013;      // starts_with(bytes, bytes) -> bytes
  FN_ENDS_WITH_STRING = 1014;       // ends_with(string, string) -> string
  FN_ENDS_WITH_BYTES = 1015;        // ends_with(bytes, bytes) -> bytes
  FN_SUBSTR_STRING = 1016;          // substr(string, int64[, int64]) -> string
  FN_SUBSTR_BYTES = 1017;           // substr(bytes, int64[, int64]) -> bytes
  FN_TRIM_STRING = 1018;            // trim(string[, string]) -> string
  FN_TRIM_BYTES = 1019;             // trim(bytes, bytes) -> bytes
  FN_LTRIM_STRING = 1020;           // ltrim(string[, string]) -> string
  FN_LTRIM_BYTES = 1021;            // ltrim(bytes, bytes) -> bytes
  FN_RTRIM_STRING = 1022;           // rtrim(string[, string]) -> string
  FN_RTRIM_BYTES = 1023;            // rtrim(bytes, bytes) -> bytes
  FN_REPLACE_STRING = 1024;         // replace(string, string, string) -> string
  FN_REPLACE_BYTES = 1025;          // replace(bytes, bytes, bytes) -> bytes
  FN_REGEXP_MATCH_STRING = 1026;    // regexp_match(string, string) -> bool
  FN_REGEXP_MATCH_BYTES = 1027;     // regexp_match(bytes, bytes) -> bool
  FN_REGEXP_EXTRACT_STRING = 1028;  // regexp_extract(string, string) -> string
  FN_REGEXP_EXTRACT_BYTES = 1029;   // regexp_extract(bytes, bytes) -> bytes
  FN_REGEXP_REPLACE_STRING = 1030;
  // regexp_replace(string, string, string) -> string
  FN_REGEXP_REPLACE_BYTES = 1031;
  // regexp_replace(bytes, bytes, bytes) -> bytes
  FN_REGEXP_EXTRACT_ALL_STRING = 1032;
  // regexp_extract_all(string, string) -> array of string
  FN_REGEXP_EXTRACT_ALL_BYTES = 1033;
  // regexp_extract_all(bytes, bytes) -> array of bytes
  FN_BYTE_LENGTH_STRING = 1034;  // byte_length(string) -> int64
  FN_BYTE_LENGTH_BYTES = 1035;   // byte_length(bytes) -> int64
                                 // semantically identical to FN_LENGTH_BYTES
  FN_CHAR_LENGTH_STRING = 1036;  // char_length(string) -> int64
                                 // semantically identical to FN_LENGTH_STRING
  FN_SPLIT_STRING = 1038;            // split(string, string) -> array of string
  FN_SPLIT_BYTES = 1039;             // split(bytes, bytes) -> array of bytes
  FN_REGEXP_CONTAINS_STRING = 1040;  // regexp_contains(string, string) -> bool
  FN_REGEXP_CONTAINS_BYTES = 1041;   // regexp_contains(bytes, bytes) -> bool
  // Converts bytes to string by replacing invalid UTF-8 characters with
  // replacement char U+FFFD.
  FN_SAFE_CONVERT_BYTES_TO_STRING = 1042;
  // Unicode normalization and casefolding functions.
  FN_NORMALIZE_STRING = 1043;  // normalize(string [, mode]) -> string
  // normalize_and_casefold(string [, mode]) -> string
  FN_NORMALIZE_AND_CASEFOLD_STRING = 1044;
  FN_TO_BASE64 = 1045;    // to_base64(bytes) -> string
  FN_FROM_BASE64 = 1046;  // from_base64(string) -> bytes
  FN_TO_HEX = 1059;       // to_hex(bytes) -> string
  FN_FROM_HEX = 1060;     // from_hex(string) -> bytes
  FN_TO_BASE32 = 1061;    // to_base32(bytes) -> string
  FN_FROM_BASE32 = 1062;  // from_base32(string) -> bytes
  // to_code_points(string) -> array<int64>
  FN_TO_CODE_POINTS_STRING = 1047;
  // to_code_points(bytes) -> array<int64>
  FN_TO_CODE_POINTS_BYTES = 1048;
  // code_points_to_string(array<int64>) -> string
  FN_CODE_POINTS_TO_STRING = 1049;
  // code_points_to_bytes(array<int64>) -> bytes
  FN_CODE_POINTS_TO_BYTES = 1050;
  FN_LPAD_BYTES = 1051;      // lpad(bytes, int64[, bytes]) -> bytes
  FN_LPAD_STRING = 1052;     // lpad(string, int64[, string]) -> string
  FN_RPAD_BYTES = 1053;      // rpad(bytes, int64[, bytes]) -> bytes
  FN_RPAD_STRING = 1054;     // rpad(string, int64[, string]) -> string
  FN_REPEAT_BYTES = 1055;    // repeat(bytes, int64) -> bytes
  FN_REPEAT_STRING = 1056;   // repeat(string, int64) -> string
  FN_REVERSE_STRING = 1057;  // reverse(string) -> string
  FN_REVERSE_BYTES = 1058;   // reverse(bytes) -> bytes

  // Control flow functions
  FN_IF = 1100;  // if
  // Coalesce is used to express the output join column in FULL JOIN.
  FN_COALESCE = 1101;  // coalesce
  FN_IFNULL = 1102;    // ifnull
  FN_NULLIF = 1103;    // nullif

  // Time functions
  FN_CURRENT_DATE = 1200;       // current_date
  FN_CURRENT_DATETIME = 1804;   // current_datetime
  FN_CURRENT_TIME = 1805;       // current_time
  FN_CURRENT_TIMESTAMP = 1260;  // current_timestamp
  FN_DATE_ADD_DATE = 1205;  // date_add
  FN_DATETIME_ADD = 1812;   // datetime_add
  FN_TIME_ADD = 1813;       // time_add
  FN_TIMESTAMP_ADD = 1261;  // timestamp_add
  FN_DATE_DIFF_DATE = 1210;  // date_diff
  FN_DATETIME_DIFF = 1816;   // datetime_diff
  FN_TIME_DIFF = 1817;       // time_diff
  FN_TIMESTAMP_DIFF = 1262;  // timestamp_diff
  FN_DATE_SUB_DATE = 1215;  // date_sub
  FN_DATETIME_SUB = 1814;   // datetime_sub
  FN_TIME_SUB = 1815;       // time_sub
  FN_TIMESTAMP_SUB = 1263;  // timestamp_sub
  FN_DATE_TRUNC_DATE = 1220;  // date_trunc
  FN_DATETIME_TRUNC = 1818;   // datetime_trunc
  FN_TIME_TRUNC = 1819;       // time_trunc
  FN_TIMESTAMP_TRUNC = 1264;  // timestamp_trunc

  FN_DATE_FROM_UNIX_DATE = 1225;  // date_from_unix_date
  FN_TIMESTAMP_FROM_INT64_SECONDS = 1289;  // timestamp_seconds
  FN_TIMESTAMP_FROM_INT64_MILLIS = 1290;   // timestamp_millis
  FN_TIMESTAMP_FROM_INT64_MICROS = 1291;   // timestamp_micros
  FN_TIMESTAMP_FROM_UNIX_SECONDS_INT64 = 1827;  // timestamp_from_unix_seconds
  FN_TIMESTAMP_FROM_UNIX_SECONDS_TIMESTAMP =
      1828;                                    // timestamp_from_unix_seconds
  FN_TIMESTAMP_FROM_UNIX_MILLIS_INT64 = 1829;  // timestamp_from_unix_millis
  FN_TIMESTAMP_FROM_UNIX_MILLIS_TIMESTAMP = 1830;  // timestamp_from_unix_millis
  FN_TIMESTAMP_FROM_UNIX_MICROS_INT64 = 1831;      // timestamp_from_unix_micros
  FN_TIMESTAMP_FROM_UNIX_MICROS_TIMESTAMP = 1832;  // timestamp_from_unix_micros
  FN_UNIX_DATE = 1230;                             // unix_date
  FN_UNIX_SECONDS_FROM_TIMESTAMP = 1268;
  FN_UNIX_MILLIS_FROM_TIMESTAMP = 1269;
  FN_UNIX_MICROS_FROM_TIMESTAMP = 1270;
  FN_DATE_FROM_TIMESTAMP = 1271;  // date
  FN_DATE_FROM_DATETIME = 1826;   // date
  FN_DATE_FROM_YEAR_MONTH_DAY = 1297;  // date
  FN_TIMESTAMP_FROM_STRING = 1272;     // timestamp
  FN_TIMESTAMP_FROM_DATE = 1273;       // timestamp
  FN_TIMESTAMP_FROM_DATETIME = 1801;   // timestamp
  FN_TIME_FROM_HOUR_MINUTE_SECOND = 1298;                     // time
  FN_TIME_FROM_TIMESTAMP = 1802;                              // time
  FN_TIME_FROM_DATETIME = 1825;                               // time
  FN_DATETIME_FROM_DATE_AND_TIME = 1299;                      // datetime
  FN_DATETIME_FROM_YEAR_MONTH_DAY_HOUR_MINUTE_SECOND = 1800;  // datetime
  FN_DATETIME_FROM_TIMESTAMP = 1803;                          // datetime
  FN_DATETIME_FROM_DATE = 1824;                               // datetime

  FN_STRING_FROM_TIMESTAMP = 1274;  // string

  // Signatures for extracting date parts, taking a date/timestamp
  // and the target date part as arguments.
  FN_EXTRACT_FROM_DATE = 1251;       // $extract
  FN_EXTRACT_FROM_DATETIME = 1806;   // $extract
  FN_EXTRACT_FROM_TIME = 1807;       // $extract
  FN_EXTRACT_FROM_TIMESTAMP = 1275;  // $extract

  // Signatures specific to extracting the DATE date part from a DATETIME or a
  // TIMESTAMP.
  FN_EXTRACT_DATE_FROM_DATETIME = 1808;   // $extract_date
  FN_EXTRACT_DATE_FROM_TIMESTAMP = 1276;  // $extract_date

  // Signatures specific to extracting the TIME date part from a DATETIME or a
  // TIMESTAMP.
  FN_EXTRACT_TIME_FROM_DATETIME = 1809;   // $extract_time
  FN_EXTRACT_TIME_FROM_TIMESTAMP = 1810;  // $extract_time

  // Signature specific to extracting the DATETIME date part from a TIMESTAMP.
  FN_EXTRACT_DATETIME_FROM_TIMESTAMP = 1811;  // $extract_datetime

  FN_FORMAT_DATE = 1293;       // format_date
  FN_FORMAT_DATETIME = 1820;   // format_datetime
  FN_FORMAT_TIME = 1821;       // format_time
  FN_FORMAT_TIMESTAMP = 1294;  // format_timestamp
  FN_PARSE_DATE = 1295;        // parse_date
  FN_PARSE_DATETIME = 1822;    // parse_datetime
  FN_PARSE_TIME = 1823;        // parse_time
  FN_PARSE_TIMESTAMP = 1296;   // parse_timestamp

  // Math functions
  FN_ABS_INT32 = 1300;     // abs
  FN_ABS_INT64 = 1301;     // abs
  FN_ABS_UINT32 = 1346;    // abs
  FN_ABS_UINT64 = 1347;    // abs
  FN_ABS_FLOAT = 1302;     // abs
  FN_ABS_DOUBLE = 1303;    // abs
  FN_ABS_NUMERIC = 1359;   // abs
  FN_SIGN_INT32 = 1341;    // sign
  FN_SIGN_INT64 = 1342;    // sign
  FN_SIGN_UINT32 = 1356;   // sign
  FN_SIGN_UINT64 = 1357;   // sign
  FN_SIGN_FLOAT = 1343;    // sign
  FN_SIGN_DOUBLE = 1344;   // sign
  FN_SIGN_NUMERIC = 1360;  // sign

  FN_ROUND_DOUBLE = 1305;               // round(double) -> double
  FN_ROUND_FLOAT = 1306;                // round(float) -> float
  FN_ROUND_NUMERIC = 1363;              // round(numeric) -> numeric
  FN_ROUND_WITH_DIGITS_DOUBLE = 1307;   // round(double, int64) -> double
  FN_ROUND_WITH_DIGITS_FLOAT = 1308;    // round(float, int64) -> float
  FN_ROUND_WITH_DIGITS_NUMERIC = 1364;  // round(numeric, int64) -> numeric
  FN_TRUNC_DOUBLE = 1309;               // trunc(double) -> double
  FN_TRUNC_FLOAT = 1310;                // trunc(float) -> float
  FN_TRUNC_NUMERIC = 1365;              // trunc(numeric) -> numeric
  FN_TRUNC_WITH_DIGITS_DOUBLE = 1311;   // trunc(double, int64) -> double
  FN_TRUNC_WITH_DIGITS_FLOAT = 1312;    // trunc(float, int64) -> float
  FN_TRUNC_WITH_DIGITS_NUMERIC = 1366;  // trunc(numeric, int64) -> numeric
  FN_CEIL_DOUBLE = 1313;                // ceil(double) -> double
  FN_CEIL_FLOAT = 1314;                 // ceil(float) -> float
  FN_CEIL_NUMERIC = 1368;               // ceil(numeric) -> numeric
  FN_FLOOR_DOUBLE = 1315;               // floor(double) -> double
  FN_FLOOR_FLOAT = 1316;                // floor(float) -> float
  FN_FLOOR_NUMERIC = 1369;              // floor(numeric) -> numeric

  FN_MOD_INT64 = 1349;    // mod(int64, int64) -> int64
  FN_MOD_UINT64 = 1351;   // mod(uint64, uint64) -> uint64
  FN_MOD_NUMERIC = 1367;  // mod(numeric, numeric) -> numeric
  FN_DIV_INT64 = 1353;    // div(int64, int64) -> int64
  FN_DIV_UINT64 = 1355;   // div(uint64, uint64) -> uint64
  FN_DIV_NUMERIC = 1362;  // div(numeric, numeric) -> numeric

  FN_IS_INF = 1317;                    // is_inf
  FN_IS_NAN = 1318;                    // is_nan
  FN_IEEE_DIVIDE_DOUBLE = 1319;        // ieee_divide
  FN_IEEE_DIVIDE_FLOAT = 1320;         // ieee_divide
  FN_SAFE_DIVIDE_DOUBLE = 1358;        // safe_divide
  FN_SAFE_DIVIDE_NUMERIC = 1361;       // safe_divide
  FN_SAFE_ADD_INT64 = 1371;            // safe_add
  FN_SAFE_ADD_UINT64 = 1372;           // safe_add
  FN_SAFE_ADD_DOUBLE = 1373;           // safe_add
  FN_SAFE_ADD_NUMERIC = 1374;          // safe_add
  FN_SAFE_SUBTRACT_INT64 = 1375;       // safe_subtract
  FN_SAFE_SUBTRACT_UINT64 = 1376;      // safe_subtract
  FN_SAFE_SUBTRACT_DOUBLE = 1377;      // safe_subtract
  FN_SAFE_SUBTRACT_NUMERIC = 1378;     // safe_subtract
  FN_SAFE_MULTIPLY_INT64 = 1379;       // safe_multiply
  FN_SAFE_MULTIPLY_UINT64 = 1380;      // safe_multiply
  FN_SAFE_MULTIPLY_DOUBLE = 1381;      // safe_multiply
  FN_SAFE_MULTIPLY_NUMERIC = 1382;     // safe_multiply
  FN_SAFE_UNARY_MINUS_INT32 = 1383;    // safe_negate
  FN_SAFE_UNARY_MINUS_INT64 = 1384;    // safe_negate
  FN_SAFE_UNARY_MINUS_FLOAT = 1385;    // safe_negate
  FN_SAFE_UNARY_MINUS_DOUBLE = 1386;   // safe_negate
  FN_SAFE_UNARY_MINUS_NUMERIC = 1387;  // safe_negate

  FN_GREATEST = 1321;  // greatest
  FN_LEAST = 1322;     // least

  FN_SQRT_DOUBLE = 1323;               // sqrt
  FN_POW_DOUBLE = 1324;                // pow
  FN_POW_NUMERIC = 1370;               // pow(numeric, numeric) -> numeric
  FN_EXP_DOUBLE = 1325;                // exp
  FN_NATURAL_LOGARITHM_DOUBLE = 1326;  // ln and log
  FN_DECIMAL_LOGARITHM_DOUBLE = 1345;  // log10
  FN_LOGARITHM_DOUBLE = 1327;          // log

  FN_COS_DOUBLE = 1328;    // cos
  FN_COSH_DOUBLE = 1329;   // cosh
  FN_ACOS_DOUBLE = 1330;   // acos
  FN_ACOSH_DOUBLE = 1331;  // acosh
  FN_SIN_DOUBLE = 1332;    // sin
  FN_SINH_DOUBLE = 1333;   // sinh
  FN_ASIN_DOUBLE = 1334;   // asin
  FN_ASINH_DOUBLE = 1335;  // asinh
  FN_TAN_DOUBLE = 1336;    // tan
  FN_TANH_DOUBLE = 1337;   // tanh
  FN_ATAN_DOUBLE = 1338;   // atan
  FN_ATANH_DOUBLE = 1339;  // atanh
  FN_ATAN2_DOUBLE = 1340;  // atan2

  // Aggregate functions.
  // TODO: Add missing type signatures.
  FN_ANY_VALUE = 1400;                // any_value
  FN_ARRAY_AGG = 1401;                // array_agg
  FN_ARRAY_CONCAT_AGG = 1442;         // array_concat_agg
  FN_AVG_INT64 = 1402;                // avg
  FN_AVG_UINT64 = 1403;               // avg
  FN_AVG_DOUBLE = 1404;               // avg
  FN_AVG_NUMERIC = 1468;              // avg
  FN_COUNT = 1405;                    // count
  FN_MAX = 1406;                      // max
  FN_MIN = 1407;                      // min
  FN_STRING_AGG_STRING = 1408;        // string_agg(s)
  FN_STRING_AGG_DELIM_STRING = 1409;  // string_agg(s, delim_s)
  FN_STRING_AGG_BYTES = 1413;         // string_agg(b)
  FN_STRING_AGG_DELIM_BYTES = 1414;   // string_agg(b, delim_b)
  FN_SUM_INT64 = 1410;                // sum
  FN_SUM_UINT64 = 1411;               // sum
  FN_SUM_DOUBLE = 1412;               // sum
  FN_SUM_NUMERIC = 1467;              // sum
  FN_BIT_AND_INT32 = 1415;            // bit_and
  FN_BIT_AND_INT64 = 1416;            // bit_and
  FN_BIT_AND_UINT32 = 1417;           // bit_and
  FN_BIT_AND_UINT64 = 1418;           // bit_and
  FN_BIT_OR_INT32 = 1419;             // bit_or
  FN_BIT_OR_INT64 = 1420;             // bit_or
  FN_BIT_OR_UINT32 = 1421;            // bit_or
  FN_BIT_OR_UINT64 = 1422;            // bit_or
  FN_BIT_XOR_INT32 = 1423;            // bit_xor
  FN_BIT_XOR_INT64 = 1424;            // bit_xor
  FN_BIT_XOR_UINT32 = 1425;           // bit_xor
  FN_BIT_XOR_UINT64 = 1426;           // bit_xor
  FN_LOGICAL_AND = 1427;              // logical_and
  FN_LOGICAL_OR = 1428;               // logical_or
  // Approximate aggregate functions.
  FN_APPROX_COUNT_DISTINCT = 1429;   // approx_count_distinct
  FN_APPROX_QUANTILES = 1430;        // approx_quantiles
  FN_APPROX_TOP_COUNT = 1431;        // approx_top_count
  FN_APPROX_TOP_SUM_INT64 = 1432;    // approx_top_sum
  FN_APPROX_TOP_SUM_UINT64 = 1433;   // approx_top_sum
  FN_APPROX_TOP_SUM_DOUBLE = 1434;   // approx_top_sum
  FN_APPROX_TOP_SUM_NUMERIC = 1469;  // approx_top_sum

  // Approximate count functions that expose the intermediate sketch.
  // These are all found in the "hll_count.*" namespace.
  //
  FN_HLL_COUNT_MERGE = 1444;          // hll_count.merge(bytes)
  FN_HLL_COUNT_EXTRACT = 1445;        // hll_count.extract(bytes), scalar
  FN_HLL_COUNT_INIT_INT64 = 1446;     // hll_count.init(int64)
  FN_HLL_COUNT_INIT_UINT64 = 1447;    // hll_count.init(uint64)
  FN_HLL_COUNT_INIT_NUMERIC = 1470;   // hll_count.init(numeric)
  FN_HLL_COUNT_INIT_STRING = 1448;    // hll_count.init(string)
  FN_HLL_COUNT_INIT_BYTES = 1449;     // hll_count.init(bytes)
  FN_HLL_COUNT_MERGE_PARTIAL = 1450;  // hll_count.merge_partial(bytes)

  // Statistical aggregate functions.
  FN_CORR = 1435;                 // corr
  FN_CORR_NUMERIC = 1471;         // corr
  FN_COVAR_POP = 1436;            // covar_pop
  FN_COVAR_POP_NUMERIC = 1472;    // covar_pop
  FN_COVAR_SAMP = 1437;           // covar_samp
  FN_COVAR_SAMP_NUMERIC = 1473;   // covar_samp
  FN_STDDEV_POP = 1438;           // stddev_pop
  FN_STDDEV_POP_NUMERIC = 1474;   // stddev_pop
  FN_STDDEV_SAMP = 1439;          // stddev_samp
  FN_STDDEV_SAMP_NUMERIC = 1475;  // stddev_samp
  FN_VAR_POP = 1440;              // var_pop
  FN_VAR_POP_NUMERIC = 1476;      // var_pop
  FN_VAR_SAMP = 1441;             // var_samp
  FN_VAR_SAMP_NUMERIC = 1477;     // var_samp

  FN_COUNTIF = 1443;  // countif

  // Approximate quantiles functions that produce or consume intermediate
  // sketches. All found in the "kll_quantiles.*" namespace.
  //
  FN_KLL_QUANTILES_INIT_INT64 = 1451;
  FN_KLL_QUANTILES_INIT_UINT64 = 1452;
  FN_KLL_QUANTILES_INIT_DOUBLE = 1453;
  FN_KLL_QUANTILES_MERGE_PARTIAL = 1454;
  FN_KLL_QUANTILES_MERGE_INT64 = 1455;
  FN_KLL_QUANTILES_MERGE_UINT64 = 1456;
  FN_KLL_QUANTILES_MERGE_DOUBLE = 1457;
  FN_KLL_QUANTILES_EXTRACT_INT64 = 1458;   // scalar
  FN_KLL_QUANTILES_EXTRACT_UINT64 = 1459;  // scalar
  FN_KLL_QUANTILES_EXTRACT_DOUBLE = 1460;  // scalar
  FN_KLL_QUANTILES_MERGE_POINT_INT64 = 1461;
  FN_KLL_QUANTILES_MERGE_POINT_UINT64 = 1462;
  FN_KLL_QUANTILES_MERGE_POINT_DOUBLE = 1463;
  FN_KLL_QUANTILES_EXTRACT_POINT_INT64 = 1464;   // scalar
  FN_KLL_QUANTILES_EXTRACT_POINT_UINT64 = 1465;  // scalar
  FN_KLL_QUANTILES_EXTRACT_POINT_DOUBLE = 1466;  // scalar

  // Analytic functions.
  FN_DENSE_RANK = 1500;       // dense_rank
  FN_RANK = 1501;             // rank
  FN_ROW_NUMBER = 1502;       // row_number
  FN_PERCENT_RANK = 1503;     // percent_rank
  FN_CUME_DIST = 1504;        // cume_dist
  FN_NTILE = 1505;            // ntile
  FN_LEAD = 1506;             // lead
  FN_LAG = 1507;              // lag
  FN_FIRST_VALUE = 1508;      // first_value
  FN_LAST_VALUE = 1509;       // last_value
  FN_NTH_VALUE = 1510;        // nth_value
  FN_PERCENTILE_CONT = 1511;  // percentile_cont
  FN_PERCENTILE_DISC = 1512;  // percentile_disc

  //
  // Misc functions.

  FN_BIT_CAST_INT32_TO_INT32 = 1604;    // bit_cast_to_int32(int32)
  FN_BIT_CAST_UINT32_TO_INT32 = 1605;   // bit_cast_to_int32(uint32)
  FN_BIT_CAST_INT64_TO_INT64 = 1606;    // bit_cast_to_int64(int64)
  FN_BIT_CAST_UINT64_TO_INT64 = 1607;   // bit_cast_to_int64(uint64)
  FN_BIT_CAST_UINT32_TO_UINT32 = 1608;  // bit_cast_to_uint32(uint32)
  FN_BIT_CAST_INT32_TO_UINT32 = 1609;   // bit_cast_to_uint32(int32)
  FN_BIT_CAST_UINT64_TO_UINT64 = 1610;  // bit_cast_to_uint64(uint64)
  FN_BIT_CAST_INT64_TO_UINT64 = 1611;   // bit_cast_to_uint64(int64)

  FN_SESSION_USER = 1612;  // session_user

  FN_GENERATE_ARRAY_INT64 = 1613;      // generate_array(int64)
  FN_GENERATE_ARRAY_UINT64 = 1614;     // generate_array(uint64)
  FN_GENERATE_ARRAY_NUMERIC = 1625;    // generate_array(numeric)
  FN_GENERATE_ARRAY_DOUBLE = 1615;     // generate_array(double)
  FN_GENERATE_DATE_ARRAY = 1616;       // generate_date_array(date)
  FN_GENERATE_TIMESTAMP_ARRAY = 1617;  // generate_timestamp_array(timestamp)

  FN_ARRAY_REVERSE = 1621;  // array_reverse(array) -> array

  FN_RANGE_BUCKET = 1680;  //  range_bucket(T, array<T>) -> int64

  FN_RAND = 1618;           // rand() -> double
  FN_GENERATE_UUID = 1679;  // generate_uuid() -> string

  FN_JSON_EXTRACT = 1619;         // json_extract(string, string)
  FN_JSON_EXTRACT_SCALAR = 1620;  // json_extract_scalar(string, string)
  FN_JSON_EXTRACT_ARRAY =
      1681;  // json_extract_array(string[, string]) -> array

  FN_TO_JSON_STRING = 1622;  // to_json_string(any[, bool]) -> string
  FN_JSON_QUERY = 1623;      // json_query(string, string)
  FN_JSON_VALUE = 1624;      // json_value(string, string)
  FN_FROM_PROTO_TIMESTAMP =
      1626;  // from_proto(google.protobuf.Timestamp) -> timestamp
  FN_FROM_PROTO_DATE = 1627;  // from_proto(google.type.Date) -> date
  FN_FROM_PROTO_TIME_OF_DAY =
      1628;  // from_proto(google.type.TimeOfDay) -> time
  FN_FROM_PROTO_DOUBLE =
      1630;  // from_proto(google.protobuf.DoubleValue) -> double
  FN_FROM_PROTO_FLOAT =
      1631;  // from_proto(google.protobuf.FloatValue) -> float
  FN_FROM_PROTO_INT64 =
      1632;  // from_proto(google.protobuf.Int64Value) -> int64
  FN_FROM_PROTO_UINT64 =
      1633;  // from_proto(google.protobuf.UInt64Value) -> uint64
  FN_FROM_PROTO_INT32 =
      1634;  // from_proto(google.protobuf.Int32Value) -> int32
  FN_FROM_PROTO_UINT32 =
      1635;  // from_proto(google.protobuf.UInt32Value) -> uint32
  FN_FROM_PROTO_BOOL = 1636;  // from_proto(google.protobuf.BoolValue) -> bool
  FN_FROM_PROTO_BYTES =
      1637;  // from_proto(google.protobuf.BytesValue) -> bytes
  FN_FROM_PROTO_STRING =
      1638;  // from_proto(google.protobuf.StringValue) -> string

  // The idempotent signatures of from_proto just return the input value
  FN_FROM_PROTO_IDEMPOTENT_TIMESTAMP =
      1639;                              // from_proto(timestamp) -> timestamp
  FN_FROM_PROTO_IDEMPOTENT_DATE = 1640;  // from_proto(date) -> date
  FN_FROM_PROTO_IDEMPOTENT_TIME = 1641;  // from_proto(time) -> time
  FN_FROM_PROTO_IDEMPOTENT_DOUBLE = 1643;  // from_proto(double) -> double
  FN_FROM_PROTO_IDEMPOTENT_FLOAT = 1644;   // from_proto(float) -> float
  FN_FROM_PROTO_IDEMPOTENT_INT64 = 1645;   // from_proto(int64) -> int64
  FN_FROM_PROTO_IDEMPOTENT_UINT64 = 1646;  // from_proto(uint64) -> uint64
  FN_FROM_PROTO_IDEMPOTENT_INT32 = 1647;   // from_proto(int32) -> int32
  FN_FROM_PROTO_IDEMPOTENT_UINT32 = 1648;  // from_proto(uint32) -> uint32
  FN_FROM_PROTO_IDEMPOTENT_BOOL = 1649;    // from_proto(bool) -> bool
  FN_FROM_PROTO_IDEMPOTENT_BYTES = 1650;   // from_proto(bytes) -> bytes
  FN_FROM_PROTO_IDEMPOTENT_STRING = 1651;  // from_proto(string) -> string

  FN_TO_PROTO_TIMESTAMP =
      1652;                 // to_proto(timestamp) -> google.protobuf.Timestamp
  FN_TO_PROTO_DATE = 1653;  // to_proto(date) -> google.type.Date
  FN_TO_PROTO_TIME = 1654;  // to_proto(time) -> google.type.TimeOfDay
  FN_TO_PROTO_DOUBLE = 1656;  // to_proto(double) -> google.protobuf.DoubleValue
  FN_TO_PROTO_FLOAT = 1657;   // to_proto(float) -> google.protobuf.FloatValue
  FN_TO_PROTO_INT64 = 1658;   // to_proto(int64) -> google.protobuf.Int64Value
  FN_TO_PROTO_UINT64 = 1659;  // to_proto(uint64) -> google.protobuf.UInt64Value
  FN_TO_PROTO_INT32 = 1660;   // to_proto(int32) -> google.protobuf.Int32Value
  FN_TO_PROTO_UINT32 = 1661;  // to_proto(uint32) -> google.protobuf.UInt32Value
  FN_TO_PROTO_BOOL = 1662;    // to_proto(bool) -> google.protobuf.BoolValue
  FN_TO_PROTO_BYTES = 1663;   // to_proto(bytes) -> google.protobuf.BytesValue
  FN_TO_PROTO_STRING = 1664;  // to_proto(string) -> google.protobuf.StringValue

  // The idempotent signatures of to_proto just return the input value
  FN_TO_PROTO_IDEMPOTENT_TIMESTAMP =
      1665;  // to_proto(google.protobuf.Timestamp) -> google.protobuf.Timestamp
  FN_TO_PROTO_IDEMPOTENT_DATE =
      1666;  // to_proto(google.type.Date) -> google.type.Date
  FN_TO_PROTO_IDEMPOTENT_TIME_OF_DAY =
      1667;  // to_proto(google.type.TimeOfDay) -> google.type.TimeOfDay
  FN_TO_PROTO_IDEMPOTENT_DOUBLE =
      1669;                             // to_proto(google.protobuf.DoubleValue)
                                        // -> google.protobuf.DoubleValue
  FN_TO_PROTO_IDEMPOTENT_FLOAT = 1670;  // to_proto(google.protobuf.FloatValue)
                                        // -> google.protobuf.FloatValue
  FN_TO_PROTO_IDEMPOTENT_INT64 = 1671;  // to_proto(google.protobuf.Int64Value)
                                        // -> google.protobuf.Int64Value
  FN_TO_PROTO_IDEMPOTENT_UINT64 =
      1672;                             // to_proto(google.protobuf.UInt64Value)
                                        // -> google.protobuf.UInt64Value
  FN_TO_PROTO_IDEMPOTENT_INT32 = 1673;  // to_proto(google.protobuf.Int32Value)
                                        // -> google.protobuf.Int32Value
  FN_TO_PROTO_IDEMPOTENT_UINT32 =
      1674;  // to_proto(google.protobuf.UInt32Value)
             // -> google.protobuf.UInt32Value
  FN_TO_PROTO_IDEMPOTENT_BOOL =
      1675;  // to_proto(google.protobuf.BoolValue) -> google.protobuf.BoolValue
  FN_TO_PROTO_IDEMPOTENT_BYTES = 1676;  // to_proto(google.protobuf.BytesValue)
                                        // -> google.protobuf.BytesValue
  FN_TO_PROTO_IDEMPOTENT_STRING =
      1677;  // to_proto(google.protobuf.StringValue)
             // -> google.protobuf.StringValue

  FN_PROTO_DEFAULT_IF_NULL =
      1678;  // proto_default_if_null(<non-message optional field access>)

  // Net functions. These are all found in the "net.*" namespace.
  FN_NET_FORMAT_IP = 1700;
  FN_NET_PARSE_IP = 1701;
  FN_NET_FORMAT_PACKED_IP = 1702;
  FN_NET_PARSE_PACKED_IP = 1703;
  FN_NET_IP_IN_NET = 1704;
  FN_NET_MAKE_NET = 1705;
  FN_NET_HOST = 1706;                 // net.host(string)
  FN_NET_REG_DOMAIN = 1707;           // net.reg_domain(string)
  FN_NET_PUBLIC_SUFFIX = 1708;        // net.public_suffix(string)
  FN_NET_IP_FROM_STRING = 1709;       // net.ip_from_string(string)
  FN_NET_SAFE_IP_FROM_STRING = 1710;  // net.safe_ip_from_string(string)
  FN_NET_IP_TO_STRING = 1711;         // net.ip_to_string(bytes)
  FN_NET_IP_NET_MASK = 1712;          // net.ip_net_mask(int64, int64)
  FN_NET_IP_TRUNC = 1713;             // net.ip_net_mask(bytes, int64)
  FN_NET_IPV4_FROM_INT64 = 1714;      // net.ipv4_from_int64(int64)
  FN_NET_IPV4_TO_INT64 = 1715;        // net.ipv4_to_int64(bytes)

  // Hashing functions.
  FN_MD5_BYTES = 1900;      // md5(bytes)
  FN_MD5_STRING = 1901;     // md5(string)
  FN_SHA1_BYTES = 1902;     // sha1(bytes)
  FN_SHA1_STRING = 1903;    // sha1(string)
  FN_SHA256_BYTES = 1904;   // sha256(bytes)
  FN_SHA256_STRING = 1905;  // sha256(string)
  FN_SHA512_BYTES = 1906;   // sha512(bytes)
  FN_SHA512_STRING = 1907;  // sha512(string)

  // Fingerprinting functions
  FN_FARM_FINGERPRINT_BYTES = 1908;   // farm_fingerprint(bytes) -> int64
  FN_FARM_FINGERPRINT_STRING = 1909;  // farm_fingerprint(string) -> int64

  // Keyset management, encryption, and decryption functions
  // ((broken link)). Requires that FEATURE_ENCRYPTION is enabled.
  FN_KEYS_NEW_KEYSET = 1910;  // keys.new_keyset(string)
  // keys.add_key_from_raw_bytes(bytes, string, bytes)
  FN_KEYS_ADD_KEY_FROM_RAW_BYTES = 1911;
  FN_KEYS_ROTATE_KEYSET = 1912;     // keys.rotate_keyset(bytes, string)
  FN_KEYS_KEYSET_LENGTH = 1913;     // keys.keyset_length(bytes)
  FN_KEYS_KEYSET_TO_JSON = 1914;    // keys.keyset_to_json(bytes)
  FN_KEYS_KEYSET_FROM_JSON = 1915;  // keys.keyset_from_json(string)
  FN_AEAD_ENCRYPT_STRING = 1916;    // aead.encrypt(bytes, string, string)
  FN_AEAD_ENCRYPT_BYTES = 1917;     // aead.encrypt(bytes, bytes, bytes)
  FN_AEAD_DECRYPT_STRING = 1918;    // aead.decrypt_string(bytes, bytes, string)
  FN_AEAD_DECRYPT_BYTES = 1919;     // aead.decrypt_bytes(bytes, bytes, bytes)
  FN_KMS_ENCRYPT_STRING = 1920;     // kms.encrypt(string, string)
  FN_KMS_ENCRYPT_BYTES = 1921;      // kms.encrypt(string, bytes)
  FN_KMS_DECRYPT_STRING = 1922;     // kms.decrypt_string(string, bytes)
  FN_KMS_DECRYPT_BYTES = 1923;      // kms.decrypt_bytes(string, bytes)

  // ST_ family of functions (Geography related - (broken link))
  // Constructors
  FN_ST_GEOG_POINT = 2000;
  FN_ST_MAKE_LINE = 2001;
  FN_ST_MAKE_LINE_ARRAY = 2002;
  FN_ST_MAKE_POLYGON = 2003;
  FN_ST_MAKE_POLYGON_ORIENTED = 2004;

  // Transformations
  FN_ST_INTERSECTION = 2007;
  FN_ST_UNION = 2008;
  FN_ST_UNION_ARRAY = 2009;
  FN_ST_DIFFERENCE = 2010;
  FN_ST_UNARY_UNION = 2011;
  FN_ST_CENTROID = 2012;
  FN_ST_BUFFER = 2013;
  FN_ST_BUFFER_WITH_TOLERANCE = 2014;
  FN_ST_SIMPLIFY = 2015;
  FN_ST_SNAP_TO_GRID = 2016;
  FN_ST_CLOSEST_POINT = 2017;
  FN_ST_BOUNDARY = 2018;

  // Predicates
  FN_ST_EQUALS = 2020;
  FN_ST_INTERSECTS = 2021;
  FN_ST_CONTAINS = 2022;
  FN_ST_COVERS = 2023;
  FN_ST_DISJOINT = 2024;
  FN_ST_INTERSECTS_BOX = 2025;
  FN_ST_DWITHIN = 2026;
  FN_ST_WITHIN = 2027;
  FN_ST_COVEREDBY = 2028;
  FN_ST_TOUCHES = 2029;

  // Accessors
  FN_ST_IS_EMPTY = 2030;
  FN_ST_IS_COLLECTION = 2031;
  FN_ST_DIMENSION = 2032;
  FN_ST_NUM_POINTS = 2033;

  // Measures
  FN_ST_LENGTH = 2040;
  FN_ST_PERIMETER = 2041;
  FN_ST_AREA = 2042;
  FN_ST_DISTANCE = 2043;
  FN_ST_MAX_DISTANCE = 2044;

  // Parsers/formatters
  FN_ST_GEOG_FROM_TEXT = 2050;
  FN_ST_GEOG_FROM_KML = 2051;
  FN_ST_GEOG_FROM_GEO_JSON = 2052;
  FN_ST_GEOG_FROM_WKB = 2056;
  FN_ST_AS_TEXT = 2053;
  FN_ST_AS_KML = 2054;
  FN_ST_AS_GEO_JSON = 2055;
  FN_ST_AS_BINARY = 2057;
  FN_ST_GEOHASH = 2058;
  FN_ST_GEOG_POINT_FROM_GEOHASH = 2059;

  // Aggregate functions
  FN_ST_UNION_AGG = 2061;
  FN_ST_ACCUM = 2062;
  FN_ST_CENTROID_AGG = 2063;

  // Other geography functions
  FN_ST_X = 2070;
  FN_ST_Y = 2071;
}
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// LINT: LEGACY_NAMES

syntax = "proto2";

package zetasql;

option java_package = "com.google.zetasql";
option java_outer_classname = "DeprecationWarningProtos";

import "zetasql/public/error_location.proto";

// Contains information about a deprecation warning emitted by the
// analyzer. Currently attached to any util::Status returned by
// AnalyzerOutput::deprecation_warnings().
message DeprecationWarning {

  enum Kind {
    // User code that switches on this enum must have a default case so
    // builds won't break if new enums get added.
    __Kind__switch_must_have_a_default__ = -1;

    UNKNOWN = 0;

    DEPRECATED_FUNCTION = 1;

    DEPRECATED_FUNCTION_SIGNATURE = 2;

    // proto.has_<field>() is not well-defined if 'proto' comes from a file with
    // proto3 syntax, but it is currently supported by the analyzer.
    PROTO3_FIELD_PRESENCE = 3;
  }

  optional Kind kind = 1;

  // TODO: Consider adding more (per-kind) structured information here
  // to facilitate automated analysis of deprecation warnings. For now, working
  // with the util::Status error messages seems sufficient.
}

// A non-util::Status-based representation of a deprecation warning that can be
// stored in objects that can be stored in the resolved AST (e.g.,
// FunctionSignatures).
//
message FreestandingDeprecationWarning {
  optional string message = 1;
  optional string caret_string = 2;
  optional ErrorLocation error_location = 3;
  optional DeprecationWarning deprecation_warning = 4;
}
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

syntax = "proto2";

package zetasql;

option java_package = "com.google.zetasql";

// This proto is used as a util::Status error payload to give the location
// for SQL parsing and analysis errors.
message ErrorLocation {

  // 1-based <line> and <column> offset in the input SQL string.
  // <column> may point to one character off the end of a line when the error
  // occurs at end-of-line.
  //
  // NOTE: <line> is computed assuming lines can be split
  // with \n, \r or \r\n, and <column> is computed assuming tabs
  // expand to eight characters.
  optional int32 line = 1 [default = 1];
  optional int32 column = 2 [default = 1];

  // An optional filename related to the error, if applicable.  May be used
  // to express more general error source information than a filename, for
  // instance if the error comes from a module imported from datascape.
  // ErrorLocation typically gets formatted as 'filename:line:column', so
  // this field content should make sense in this format (i.e., it should
  // probably avoid whitespace).
  optional string filename = 3;

  // An optional list of error source information for the related Status.
  // The last element in this list is the immediate error cause, with
  // the previous element being its cause, etc.  These error sources should
  // normally be displayed in reverse order.
  repeated ErrorSource error_source = 4;
}

// This proto indicates an error that is the source of another error.
// It is expected that all of <error_message>, <error_message_caret_string>,
// and <error_location> are populated in normal use cases.
//
// An example of usage is for deferred, nested resolution of SQL expressions
// related to SQL UDFs inside Modules.  Resolving a SQL UDF (func1) that
// references another SQL UDF (func2) can cause nested resolution, and if the
// resolution of func2 fails then that error information is captured in an
// ErrorSource that is attached to the error Status returned by func1's
// resolution.  The returned Status may also have its own ErrorLocation
// related to func1, while the ErrorSource will be specific to func2's
// resolution.
message ErrorSource {
  // The error message for this ErrorSource.
  optional string error_message = 1;

  // An additional error string added to <error_message> when in
  // ErrorMessageMode ERROR_MESSAGE_MODE_MULTI_LINE_WITH_CARET.  This
  // is constructed as one line of input text, a newline, and then a
  // second line with the caret in the position pointing at the error
  // in the first line.
  optional string error_message_caret_string = 2;

  // The error location indicating a position in the original input file
  // containing the statement with the error.
  // This <error_location> should not itself have <error_source> filled in.
  optional ErrorLocation error_location = 3;
}
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

syntax = "proto2";

package zetasql;

option java_package = "com.google.zetasql";
option java_outer_classname = "ZetaSQLFunctions";

enum SignatureArgumentKind {
  // A specific concrete Type.  Each argument with ARG_TYPE_FIXED should include
  // an instance of the Type object to indicate the exact type to use.
  ARG_TYPE_FIXED = 0;

  // Templated type.  All arguments with this type must be the same type.
  // For example,
  //   IF <bool> THEN <T1> ELSE <T1> END -> <T1>
  ARG_TYPE_ANY_1 = 1;

  // Templated type.  All arguments with this type must be the same type.
  // For example,
  //   CASE <T1> WHEN <T1> THEN <T2>
  //             WHEN <T1> THEN <T2> ELSE <T2> END -> <T2>
  ARG_TYPE_ANY_2 = 2;

  // Templated array type.  All arguments with this type must be the same
  // type.  Additionally, all arguments with this type must be an array
  // whose element type matches arguments with ARG_TYPE_ANY_1 type.
  // For example,
  //   FIRST(<array<T1>>) -> <T1>
  ARG_ARRAY_TYPE_ANY_1 = 3;

  // Templated array type.  All arguments with this type must be the same
  // type.  Additionally, all arguments with this type must be an array
  // whose element type matches arguments with ARG_TYPE_ANY_2 type.
  // For example,
  //   LAST(<array<T2>>) -> <T2>
  ARG_ARRAY_TYPE_ANY_2 = 4;

  // Templated proto type. All arguments with this type must be the same type.
  // e.g.:
  //   DEBUGSTRING(<proto>) -> <string>
  ARG_PROTO_ANY = 5;

  // Templated struct type. All arguments with this type must be the same type.
  // e.g.:
  //   DEBUGSTRING(<struct>) -> <string>
  ARG_STRUCT_ANY = 6;

  // Templated enum type. All arguments with this type must be the same type.
  // e.g.:
  //   ENUM_NAME(<enum>, 5) -> <string>
  ARG_ENUM_ANY = 7;

  // Arbitrary Type. Multiple arguments with this type do not need to be the
  // same type. This does not include relation arguments.
  ARG_TYPE_ARBITRARY = 8;

  // Relation type. This is only valid for table-valued functions (TVFs). This
  // specifies a relation of any number and types of columns. Multiple arguments
  // with this type do not necessarily represent the same relation.
  //
  // Background: each TVF may accept value or relation arguments. The signature
  // specifies whether each argument should be a value or a relation. For a
  // value argument, the signature may use one of the other
  // SignatureArgumentKinds in this list.
  //
  // For more information, please see table_valued_function.h.
  ARG_TYPE_RELATION = 9;

  // This is used for a non-existent return type for signatures that do not
  // return a value.  This can only be used as a return type, and only in
  // contexts where there is no return (e.g. Procedures, or signatures in
  // ResolvedDropFunctionStmt).
  ARG_TYPE_VOID = 10;

  // Model type. This is only valid for table-valued functions (TVFs). This
  // specifies a model for ML-related TVFs.
  // For more information, please see TVFModelArgument in
  // table_valued_function.h.
  ARG_TYPE_MODEL = 11;

  // Connection type. This is only valid for table-valued functions (TVFs). This
  // sepcifies a connection for EXTERNAL_QUERY TVF.
  // For more information, please see TVFConnectionArgument in
  // table_valued_function.h.
  ARG_TYPE_CONNECTION = 12;

  __SignatureArgumentKind__switch_must_have_a_default__ = -1;
}

message FunctionEnums {
  enum ArgumentCardinality {
    REQUIRED = 0;
    REPEATED = 1;  // occurs 0 or more times
    OPTIONAL = 2;
  }

  // Function argument always has mode NOT_SET.
  // Procedure argument is in one of the 3 modes:
  // IN: argument is used only for input to the procedure. It is also the
  //     default mode for procedure argument if no mode is specified.
  // OUT: argument is used as output of the procedure.
  // INOUT: argument is used both for input to and output from the procedure.
  enum ProcedureArgumentMode {
    NOT_SET = 0;
    IN = 1;
    OUT = 2;
    INOUT = 3;
  }

  enum WindowOrderSupport {
    ORDER_UNSUPPORTED = 0;
    ORDER_OPTIONAL = 1;
    ORDER_REQUIRED = 2;
  }

  // A Function must have exactly one of the three modes: SCALAR, AGGREGATE,
  // and ANALYTIC. It is not possible to select a mode based on overload
  // resolution.
  // 1) A SCALAR function cannot specify support for the OVER clause in
  //    <function_options>.
  // 2) An AGGREGATE function can specify support for the OVER clause in
  //    <function_options>. For an AGGREGATE function with the support,
  //    it acts as an analytic function if an OVER clause follows the function
  //    call. Otherwise, it is treated as a regular aggregate function.
  // 3) An ANALYTIC function must specify support for the OVER clause in
  //    <function_options>. It cannot be used without OVER.
  enum Mode {
    SCALAR = 1;
    AGGREGATE = 2;
    ANALYTIC = 3;
  }

  // The volatility of a function determines how multiple executions of
  // a function are related, and whether we always get the same answer when
  // calling the function with the same input values.  Optimizers may use
  // this property when considering transformations like common subexpression
  // elimination.  Functions marked VOLATILE must be evaluated independently
  // each time time they occur.
  // This is based on postgres:
  // http://www.postgresql.org/docs/9.4/static/xfunc-volatility.html
  //
  // Note that volatility is a property of a Function, not an expression.
  // The function `+` is immutable, but in the expression "a + b", the
  // column references do not have a volatility property, and neither does the
  // expression.
  //
  // Functions like ANY_VALUE do not fit cleanly into this classification.
  // ANY_VALUE is not required to be deterministic, but is allowed to be.
  // Unlike RAND(), two calls to ANY_VALUE(x) are allowed to be combined by an
  // optimizer so the result is shared.  Such functions are marked IMMUTABLE.
  enum Volatility {
    IMMUTABLE = 0;  // Same answer always (for the same inputs).  e.g. 1+2
                    // Optimizers can always reuse results for computing
                    // this function on the same input values.

    STABLE = 1;  // Same answer within same statement (for the same inputs).
                 // e.g. CURRENT_TIMESTAMP()
                 // Optimizers can always reuse results for computing
                 // this function on the same input values
                 // within the same statement.

    VOLATILE = 2;  // Each invocation is independent and may return a
                   // different value, or cause side-effects.
                   // e.g. RAND().
                   // Optimizers cannot combine multiple calls to this
                   // function or reuse results.  e.g. If RAND() is called
                   // twice, it must produce an output random value
                   // independently on each call.
  }

  // This is an enumeration of all types of table-valued functions that
  // ZetaSQL supports serializing and deserializing. It exists for use with
  // the TableValuedFunction::RegisterDeserializer method to associate each TVF
  // type with a callback to generate a new instance. Please see the comments
  // for that method for more information.
  enum TableValuedFunctionType {
    INVALID = 0;
    FIXED_OUTPUT_SCHEMA_TVF = 1;
    FORWARD_INPUT_SCHEMA_TO_OUTPUT_SCHEMA_TVF = 2;
    TEMPLATED_SQL_TVF = 3;
  }
}
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

syntax = "proto2";

package zetasql;

import "google/protobuf/descriptor.proto";

option java_package = "com.google.zetasql";
option java_outer_classname = "ZetaSQLOptions";

// ZetaSQL language versions.
// See (broken link) for more detail.
//
// A language version defines a stable set of features and required semantics.
// LanguageVersion VERSION_x_y implicitly includes the LanguageFeatures below
// named FEATURE_V_x_y_*.
//
// The features and behavior supported by an engine can be expressed as a
// LanguageVersion plus a set of LanguageFeatures added on top of that version.
//
// New version numbers will be introduced periodically, and will normally
// include the new features that have been specified up to that point.
// Engines should move their version number forwards over time rather than
// accumulating large sets of LanguageFeatures.
//
// LINT: LEGACY_NAMES
enum LanguageVersion {
  // All current features, including features that are not part of a frozen
  // version.  For example, when v1.0 is the maximum released version number,
  // this includes features that have been developed for v1.1.
  // This does not include cross-version or experimental features.
  // WARNING: Using this version means query behavior will change under you.
  VERSION_CURRENT = 1;

  VERSION_1_0 = 10000;  // Version 1.0, frozen January 2015.

  VERSION_1_1 = 11000;  // Version 1.1, frozen February 2017.

  VERSION_1_2 = 12000;  // Version 1.2, frozen January 2018.

  VERSION_1_3 = 13000;  // Version 1.3.  New features are being added here.

  // User code that switches on this enum must have a default case so
  // builds won't break if new enums get added.
  __LanguageVersion__switch_must_have_a_default__ = -1;
}

extend google.protobuf.EnumValueOptions {
  // Only for use on LanguageFeature enum values.
  optional LanguageFeatureOptions language_feature_options = 170219291;
}

// Annotations for LanguageFeature enum values. Only for consumption by
// ZetaSQL code.
//
// LanguageOptions::EnableMaximumLanguageFeatures() enables all features with
// 'ideally_enabled == true' and 'in_development == false'.
//
// LanguageOptions::EnableMaximumLanguageFeaturesForDevelopment() enables all
// features with 'ideally_enabled == true'.
message LanguageFeatureOptions {
  // Indicates whether a feature is enabled in the idealized ZetaSQL. (One
  // reason to disable a feature is if it exists only to support backwards
  // compatibility with older ZetaSQL behavior.)
  optional bool ideally_enabled = 1 [default = true];

  // Indicates whether a feature is still undergoing development. Users should
  // not enable features that are still in development, but internal ZetaSQL
  // tests may do so.
  optional bool in_development = 2 [default = false];
}

// The list of optional features that engines may or may not support.
// Features can be opted into in AnalyzerOptions.
//
// There are three types of LanguageFeatures.
// * Cross-version - Optional features that can be enabled orthogonally to
//                   versioning.  Some engines will never implement these
//                   features, and zetasql code will always support this
//                   switch.
// * Versioned - Features that describe behavior changes adopted as of some
//               language version.  Eventually, all engines should support these
//               features, and switches in the zetasql code (and tests)
//               should eventually be removed.
//               All of these, and only these, show up in VERSION_CURRENT.
// * Experimental - Features not currently part of any language version.
//
// All optional features are off by default.  Some features have a negative
// meaning, so turning them on will remove a feature or enable an error.
enum LanguageFeature {
  // CROSS-VERSION FEATURES
  //
  // These are features that can be opted into independently from versioning.
  // Some features may disable operations that are normally allowed by default.
  //
  // These features should not change semantics, other than whether a feature
  // is allowed or not.  Versioned options may further the behavior of these
  // features, if they are enabled.  For example, an engine may choose to
  // support DML, orthogonally to versioning.  If it supports DML, and
  // specified semantics for DML may change over time, and the engine may use
  // versioned options to choose DML behavior as of v1.0 or v1.1.

  // Enable analytic functions.
  // See (broken link).
  FEATURE_ANALYTIC_FUNCTIONS = 1;

  // Enable the TABLESAMPLE clause on scans.
  // See (broken link).
  FEATURE_TABLESAMPLE = 2;

  // If enabled, give an error on GROUP BY, DISTINCT or set operations (other
  // than UNION ALL) on floating point types. This feature is disabled in the
  // idealized ZetaSQL (i.e. LanguageOptions::EnableMaximumLanguageFeatures)
  // because enabling it turns off support for a feature that is normally on by
  // default.
  FEATURE_DISALLOW_GROUP_BY_FLOAT = 3
      [(language_feature_options).ideally_enabled = false];

  // If enabled, treats TIMESTAMP literal as 9 digits (nanos) precision.
  // Otherwise TIMESTAMP has 6 digits (micros) precision.
  // In general, a TIMESTAMP value has only 6 digits precision. This feature
  // will only affect how a timestamp literal string is interpreted into a
  // TIMESTAMP value. If enabled, a timestamp literal string can have up to 9
  // digits of subseconds(nanos). Otherwise, it can only have up to 6 digits of
  // subseconds (micros). 9 digits subsecond literal is not a valid timestamp
  // string in the later case.
  FEATURE_TIMESTAMP_NANOS = 5;

  // Enable support for JOINs in UPDATE statements, see
  // (broken link).
  FEATURE_DML_UPDATE_WITH_JOIN = 6;

  // Enable table-valued functions. For more information, see
  // table_valued_functions.h.
  FEATURE_TABLE_VALUED_FUNCTIONS = 8;

  // This enables support for CREATE AGGREGATE FUNCTION.
  FEATURE_CREATE_AGGREGATE_FUNCTION = 9;

  // This enables support for CREATE TABLE FUNCTION.
  // For more information, see (broken link).
  FEATURE_CREATE_TABLE_FUNCTION = 10;

  // This enables support for GROUP BY ROLLUP.
  FEATURE_GROUP_BY_ROLLUP = 12;

  // This enables support for creating and calling functions with templated
  // argument types, using CREATE FUNCTION, CREATE AGGREGATE FUNCTION, or CREATE
  // TABLE FUNCTION statements. For example, a function argument may be written
  // as "argument ANY TYPE" to match against any scalar value. For more
  // information, see (broken link).
  FEATURE_TEMPLATE_FUNCTIONS = 13;

  // Enables support for PARTITION BY with CREATE TABLE and CREATE TABLE AS.
  // See (broken link).
  FEATURE_CREATE_TABLE_PARTITION_BY = 14;

  // Enables support for CLUSTER BY with CREATE TABLE and CREATE TABLE AS.
  // See (broken link).
  FEATURE_CREATE_TABLE_CLUSTER_BY = 15;

  // NUMERIC type support, see (broken link).
  FEATURE_NUMERIC_TYPE = 16;

  // Enables support for NOT NULL annotation in CREATE TABLE.
  // See comment on FEATURE_CREATE_TABLE_FIELD_ANNOTATIONS and
  // (broken link) for details.
  FEATURE_CREATE_TABLE_NOT_NULL = 17;

  // Enables support for annotations (e.g., NOT NULL and OPTIONS()) for struct
  // fields and array elements in CREATE TABLE.
  // Does not affect table options or table column annotations.
  //
  // Example: Among the following queries
  // Q1: CREATE TABLE t (c STRUCT<a INT64> NOT NULL)
  // Q2: CREATE TABLE t (c STRUCT<a INT64 NOT NULL>)
  // Q3: CREATE TABLE t (c STRUCT<a INT64> OPTIONS(foo=1))
  // Q4: CREATE TABLE t (c STRUCT<a INT64 OPTIONS(foo=1)>)
  // Q5: CREATE TABLE t (c STRUCT<a INT64 NOT NULL OPTIONS(foo=1)>)
  //
  // Allowed queries                  FEATURE_CREATE_TABLE_FIELD_ANNOTATIONS
  //                                         =0               =1
  // FEATURE_CREATE_TABLE_NOT_NULL=0        {Q3}           {Q3, Q4}
  // FEATURE_CREATE_TABLE_NOT_NULL=1      {Q1, Q3}    {Q1, Q2, Q3, Q4, Q5}
  //
  // See (broken link).
  FEATURE_CREATE_TABLE_FIELD_ANNOTATIONS = 18;

  // Enables support for column definition list in CREATE TABLE AS SELECT.
  // Example: CREATE TABLE t (x FLOAT64) AS SELECT 1 x
  // The features in the column definition list are controlled by
  // FEATURE_CREATE_TABLE_NOT_NULL and FEATURE_CREATE_TABLE_FIELD_ANNOTATIONS.
  FEATURE_CREATE_TABLE_AS_SELECT_COLUMN_LIST = 19;

  // Indicates that an engine that supports primary keys does not allow any
  // primary key column to be NULL. Similarly, non-NULL primary key columns
  // cannot have any NULL array elements or struct/proto fields anywhere inside
  // them.
  //
  // Only interpreted by the compliance tests and the reference implementation
  // (not the analyzer). It exists so that engines can disable tests for this
  // atypical behavior without impacting their compliance ratios. It can never
  // be totally enforced in the analyzer because the analyzer cannot evaluate
  // expressions.
  //
  // TODO: When this feature is enabled, the reference implementation
  // forbids NULL primary key columns, but it allows NULL array elements and
  // NULL struct/proto fields. Change this behavior if we ever want to write
  // compliance tests for these cases.
  FEATURE_DISALLOW_NULL_PRIMARY_KEYS = 20
      [(language_feature_options).ideally_enabled = false];

  // Indicates that an engine that supports primary keys does not allow any
  // primary key column to be modified with UPDATE.
  //
  // Only interpreted by the compliance tests and the reference implementation
  // (not the analyzer) for now. It exists so that engines can disable tests for
  // this atypical behavior without impacting their compliance ratios.
  //
  // TODO: Consider exposing information about primary keys to the
  // analyzer and enforcing this feature there.
  FEATURE_DISALLOW_PRIMARY_KEY_UPDATES = 21
      [(language_feature_options).ideally_enabled = false];

  // Enables support for the TABLESAMPLE clause applied to table-valued function
  // calls. For more information about table-valued functions, please see
  // table_valued_functions.h and (broken link).
  FEATURE_TABLESAMPLE_FROM_TABLE_VALUED_FUNCTIONS = 22;

  // Enable encryption- and decryption-related functions.
  // See (broken link).
  FEATURE_ENCRYPTION = 23;

  // Geography type support per (broken link)
  FEATURE_GEOGRAPHY = 25;

  // Enables support for stratified TABLESAMPLE. For more information about
  // stratified sampling, please see: (broken link).
  FEATURE_STRATIFIED_RESERVOIR_TABLESAMPLE = 26;

  // Enables foreign keys (see (broken link)).
  FEATURE_FOREIGN_KEYS = 27;

  // Enables BETWEEN function signatures for UINT64/INT64 comparisons.
  FEATURE_BETWEEN_UINT64_INT64 = 28
      [(language_feature_options).in_development = true];

  // Enables check constraint (see (broken link)).
  FEATURE_CHECK_CONSTRAINT = 29;

  // Enables statement parameters in the GRANTEE list of GRANT, REVOKE, CREATE
  // ROW POLICY, and ALTER ROW POLICY statements.
  // TODO: The behavior of this feature is intended to become
  // mandatory.  This is a temporary feature, that preserves existing
  // behavior prior to engine migrations.  Once all engines have migrated,
  // this feature will be deprecated/removed and the new behavior will be
  // mandatory.
  FEATURE_PARAMETERS_IN_GRANTEE_LIST = 30;

  // Enables support for named arguments in function calls using a syntax like
  // this: 'SELECT function(argname => 'value', otherarg => 42)'. Function
  // arguments with associated names in the signature options may specify values
  // by providing the argument name followed by an equals sign and greater than
  // sign (=>) followed by a value for the argument. Function calls may include
  // a mix of positional arguments and named arguments. The resolver will
  // compare provided arguments against function signatures and handle signature
  // matching appropriately. For more information, please refer to
  // (broken link).
  FEATURE_NAMED_ARGUMENTS = 31;

  // Enables support for the old syntax for the DDL for ROW ACCESS POLICY,
  // previously called ROW POLICY.
  // When this feature is enabled, using the old syntax will not throw errors
  // for CREATE ROW [ACCESS] POLICY and DROP ALL ROW [ACCESS] POLICIES, but the
  // new syntax can still be used.
  // When it is not enabled, the new syntax must be used for CREATE
  // ROW ACCESS POLICY and DROP ALL ROW ACCESS POLICIES.
  // The new syntax is always required for ALTER ROW ACCESS POLICY and DROP ROW
  // ACCESS POLICY: at the time of this writing, these statements are new/not in
  // use.
  // This is a temporary feature that preserves legacy engine behavior that
  // will be deprecated, and the new syntax will become mandatory (b/135116351).
  // For more details on syntax changes, see (broken link).
  FEATURE_ALLOW_LEGACY_ROW_ACCESS_POLICY_SYNTAX = 32;

  // Enables support for PARTITION BY with CREATE MATERIALIZED VIEW.
  // See (broken link).
  FEATURE_CREATE_MATERIALIZED_VIEW_PARTITION_BY = 33;

  // Enables support for CLUSTER BY with CREATE MATERIALIZED VIEW.
  // See (broken link).
  FEATURE_CREATE_MATERIALIZED_VIEW_CLUSTER_BY = 34;

  // Enables support for column definition list in CREATE EXTERNAL TABLE.
  // Example: CREATE EXTERNAL TABLE t (x FLOAT64)
  FEATURE_CREATE_EXTERNAL_TABLE_WITH_TABLE_ELEMENT_LIST = 35;

  // Enables support for PARTITION BY in CREATE EXTERNAL TABLE.
  // Example: CREATE EXTERNAL TABLE t (x FLOAT64) PARTITION BY X OPTIONS()
  // Make sure the feature FEATURE_CREATE_EXTERNAL_TABLE_WITH_TABLE_ELEMENT_LIST
  // is enabled to support column lookup
  FEATURE_CREATE_EXTERNAL_TABLE_WITH_PARTITION_BY = 36;

  // Enables support for CLUSTER BY in CREATE EXTERNAL TABLE.
  // Example:
  // CREATE EXTERNAL TABLE t (x FLOAT64) PARTITION BY X CLUSTER BY X OPTIONS()
  // Make sure the feature FEATURE_CREATE_EXTERNAL_TABLE_WITH_TABLE_ELEMENT_LIST
  // is enabled to support column lookup.
  FEATURE_CREATE_EXTERNAL_TABLE_WITH_CLUSTER_BY = 37;

  // Enables support for NUMERIC data type as input in the binary statistics
  // functions.
  FEATURE_NUMERIC_COVAR_CORR_SIGNATURES = 38
      [(language_feature_options).in_development = true];

  // Enables support for NUMERIC data type as input in the unary statistics
  // functions.
  FEATURE_NUMERIC_VARIANCE_STDDEV_SIGNATURES = 39
      [(language_feature_options).in_development = true];

  // -> Add more cross-version features here.
  // -> DO NOT add more versioned features into versions that are frozen.
  //    New features should be added for the *next* version number.

  // VERSIONED FEATURES
  // These are features or changes as of some version.
  // Each should start with a prefix FEATURE_V_x_y_.  The feature will be
  // included in the default set enabled for LanguageVersion VERSION_x_y.
  //
  // Features that will remain optional for compliance, and are not expected to
  // be implemented in all engines, should be added as cross-version features
  // (above) instead.
  //
  // Some versioned features may have dependencies and only make sense if
  // other features are also enabled.  Dependencies should be commented here.

  // Version 1.1 features
  // * Frozen in February 2017.
  // * Do not add new features here.

  // Enable ORDER BY COLLATE.  See (broken link).
  FEATURE_V_1_1_ORDER_BY_COLLATE = 11001;

  // Enable WITH clause on subqueries.  Without this, WITH is allowed
  // only at the top level.  The WITH subqueries still cannot be
  // correlated subqueries.
  FEATURE_V_1_1_WITH_ON_SUBQUERY = 11002;

  // Enable the SELECT * EXCEPT and SELECT * REPLACE features.
  // See (broken link).
  FEATURE_V_1_1_SELECT_STAR_EXCEPT_REPLACE = 11003;

  // Enable the ORDER BY in aggregate functions.
  // See (broken link)
  FEATURE_V_1_1_ORDER_BY_IN_AGGREGATE = 11004;

  // Enable casting between different array types.
  FEATURE_V_1_1_CAST_DIFFERENT_ARRAY_TYPES = 11005;

  // Enable comparing array equality.
  FEATURE_V_1_1_ARRAY_EQUALITY = 11006;

  // Enable LIMIT in aggregate functions.
  FEATURE_V_1_1_LIMIT_IN_AGGREGATE = 11007;

  // Enable HAVING modifier in aggregate functions.
  FEATURE_V_1_1_HAVING_IN_AGGREGATE = 11008;

  // Enable IGNORE/RESPECT NULLS modifier in analytic functions.
  FEATURE_V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC = 11009;

  // Enable IGNORE/RESPECT NULLS modifier in aggregate functions.
  FEATURE_V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE = 11010;

  // Enable FOR SYSTEM_TIME AS OF (time travel).
  // See (broken link).
  FEATURE_V_1_1_FOR_SYSTEM_TIME_AS_OF = 11011;

  // Version 1.2 features
  // * Frozen in January 2018.
  // * Do not add new features here.

  // Enable TIME and DATETIME types and related functions.
  FEATURE_V_1_2_CIVIL_TIME = 12001;

  // Enable SAFE mode function calls.  e.g. SAFE.FUNC(...) for FUNC(...).
  // (broken link).
  FEATURE_V_1_2_SAFE_FUNCTION_CALL = 12002;

  // Enable support for GROUP BY STRUCT.
  FEATURE_V_1_2_GROUP_BY_STRUCT = 12003;

  // Enable use of proto extensions with NEW.
  FEATURE_V_1_2_PROTO_EXTENSIONS_WITH_NEW = 12004;

  // Enable support for GROUP BY ARRAY.
  FEATURE_V_1_2_GROUP_BY_ARRAY = 12005;

  // Enable use of proto extensions with UPDATE ... SET.
  FEATURE_V_1_2_PROTO_EXTENSIONS_WITH_SET = 12006;

  // Allows nested DML statements to refer to names defined in the parent
  // scopes. Without this, a nested DML statement can only refer to names
  // created in the local statement - i.e. the array element.
  // Examples that are allowed only with this option:
  //   UPDATE Table t SET (UPDATE t.ArrayColumn elem SET elem = t.OtherColumn)
  //   UPDATE Table t SET (DELETE t.ArrayColumn elem WHERE elem = t.OtherColumn)
  //   UPDATE Table t SET (INSERT t.ArrayColumn VALUES (t.OtherColumn))
  //   UPDATE Table t SET (INSERT t.ArrayColumn SELECT t.OtherColumn)
  FEATURE_V_1_2_CORRELATED_REFS_IN_NESTED_DML = 12007;

  // Enable use of WEEK(<Weekday>) with the functions that support it.
  FEATURE_V_1_2_WEEK_WITH_WEEKDAY = 12008;

  // Enable use of array element [] syntax in targets with UPDATE ... SET.
  // For example, allow UPDATE T SET a.b[OFFSET(0)].c = 5.
  FEATURE_V_1_2_ARRAY_ELEMENTS_WITH_SET = 12009;

  // Enable nested updates/deletes of the form
  // UPDATE/DELETE ... WITH OFFSET AS ... .
  FEATURE_V_1_2_NESTED_UPDATE_DELETE_WITH_OFFSET = 12010;

  // Enable Generated Columns on CREATE and ALTER TABLE statements.
  // See (broken link).
  FEATURE_V_1_2_GENERATED_COLUMNS = 12011;

  // Version 1.3 features

  // -> Add more versioned features here.
  // -> Always update AnalyzerOptions::GetLanguageFeaturesForVersion
  //    in ../common/language_options.cc.

  // Enables support for the PROTO_DEFAULT_IF_NULL() function, see
  // (broken link)
  FEATURE_V_1_3_PROTO_DEFAULT_IF_NULL = 13001;

  // Enables support for proto field pseudo-accessors in the EXTRACT function.
  // For example, EXTRACT(FIELD(x) from foo) will extract the value of the field
  // x defined in message foo. EXTRACT(HAS(x) from foo) will return a boolean
  // denoting if x is set in foo or NULL if foo is NULL. EXTRACT(RAW(x) from
  // foo) will get the value of x on the wire (i.e., without applying any
  // FieldFormat.Format annotations or automatic conversions). If the field is
  // missing, the default is always returned, which is NULL for message fields
  // and the field default (either the explicit default or the default default)
  // for primitive fields. If the containing message is NULL, NULL is returned.
  // (broken link)
  FEATURE_V_1_3_EXTRACT_FROM_PROTO = 13002;

  // If enabled, the analyzer will return an error when attempting to check
  // if a proto3 scalar field has been explicitly set (e.g.,
  // proto3.has_scalar_field and EXTRACT(HAS(scalar_field) from proto3)). This
  // is not allowed because proto3 does not generate has_ accessors for scalar
  // fields.
  FEATURE_V_1_3_DISALLOW_PROTO3_HAS_SCALAR_FIELD = 13003;

  // Enable array ordering (and non-equality comparisons).  This enables
  // arrays in the ORDER BY of a query, as well as in aggregate and analytic
  // function arguments.  Also enables inequality comparisons between arrays
  // (<, <=, >, >=).  This does not enable arrays for MIN/MAX/GREATEST/LEAST,
  // since the semantics are not well defined over sets of arrays.
  //
  // Spec:  (broken link)
  FEATURE_V_1_3_ARRAY_ORDERING = 13004;

  // Allow omitting column and value lists in INSERT statement and INSERT clause
  // of MERGE statement.
  // Spec: (broken link)
  FEATURE_V_1_3_OMIT_INSERT_COLUMN_LIST = 13005;

  // If enabled, the 'use_defaults' and 'use_field_defaults' annotations are
  // ignored for proto3 scalar fields. This results in the default value always
  // being returned for proto3 scalar fields that are not explicitly set,
  // including when they are annotated with 'use_defaults=false' or their parent
  // message is annotated with 'use_field_defaults=false'. This aligns with
  // proto3 semantics as proto3 does not expose whether scalar fields are set or
  // not.
  FEATURE_V_1_3_IGNORE_PROTO3_USE_DEFAULTS = 13006;

  // Enables support for the REPLACE_FIELDS() function. REPLACE_FIELDS(p,
  // <value> AS <field_path>) returns the proto obtained by setting p.field_path
  // = value. If value is NULL, this unsets field_path or returns an error if
  // the last component of field_path is a required field. Multiple fields can
  // be modified: REPLACE_FIELDS(p, <value_1> AS <field_path_1>, ..., <value_n>
  // AS <field_path_n>). REPLACE_FIELDS() can also be used to modify structs
  // using the similar syntax: REPLACE_FIELDS(s, <value> AS
  // <struct_field_path>).
  // (broken link)
  FEATURE_V_1_3_REPLACE_FIELDS = 13007
      [(language_feature_options).in_development = true];

  // Enable NULLS FIRST/NULLS LAST in ORDER BY expressions.
  FEATURE_V_1_3_NULLS_FIRST_LAST_IN_ORDER_BY = 13008;

  // Allows dashes in the first part of multi-part table name. This is to
  // accommodate GCP project names which use dashes instead of underscores, e.g.
  // crafty-tractor-287. So fully qualified table name which includes project
  // name normally has to be quoted in the query, i.e. SELECT * FROM
  // `crafty-tractor-287`.dataset.table This feature allows it to be used
  // unquoted, i.e. SELECT * FROM crafty-tractor-287.dataset.table
  FEATURE_V_1_3_ALLOW_DASHES_IN_TABLE_NAME = 13009;

  // CONCAT allows arguments of different types, automatically coerced to
  // STRING for FN_CONCAT_STRING signature. Only types which have CAST to
  // STRING defined are allowed, and BYTES is explicitly excluded (since BYTES
  // should match FN_CONCAT_BYTES signature).
  FEATURE_V_1_3_CONCAT_MIXED_TYPES = 13010
      [(language_feature_options).ideally_enabled = false];

  // EXPERIMENTAL FEATURES
  // These are features supported in the code that are not currently part of
  // officially supported ZetaSQL as of any version.
  //
  // An example:
  // FEATURE_EXPERIMENTAL_DECIMAL_DATA_TYPES = 999001;
  //
  // -> Add more experimental features here.
  //
  // TODO: Retire the convention of FEATURE_EXPERIMENTAL_xxx features
  // and just use the enum value annotations where appropriate.

  // Enable ZetaSQL MODULES.  For an engine to fully opt into this feature,
  // they must enable this feature flag and add support for the related
  // StatementKinds: RESOLVED_IMPORT_STMT and RESOLVED_MODULE_STMT.
  // See (broken link)
  FEATURE_EXPERIMENTAL_MODULES = 999002
      [(language_feature_options).in_development = true];

  // These are not real features. They are just for unit testing the handling of
  // various LanguageFeatureOptions.
  FEATURE_TEST_IDEALLY_ENABLED_BUT_IN_DEVELOPMENT = 999991
      [(language_feature_options).in_development = true];
  FEATURE_TEST_IDEALLY_DISABLED = 999992
      [(language_feature_options).ideally_enabled = false];
  FEATURE_TEST_IDEALLY_DISABLED_AND_IN_DEVELOPMENT = 999993
      [(language_feature_options) = {
        ideally_enabled: false,
        in_development: true
      }];

  // User code that switches on this enum must have a default case so
  // builds won't break if new enums get added.
  __LanguageFeature__switch_must_have_a_default__ = -1;
}

// This can be used to select strict name resolution mode.
//
// In strict mode, implicit column names cannot be used unqualified.
// This ensures that existing queries will not be broken if additional
// elements are added to the schema in the future.
//
// For example,
//   SELECT c1, c2 FROM table1, table2;
// is not legal in strict mode because another column could be added to one of
// these tables, making the query ambiguous.  The query must be written
// with aliases in strict mode:
//   SELECT t1.c1, t2.c2 FROM table1 t1, table t2;
//
// SELECT * is also not allowed in strict mode because the number of output
// columns may change.
//
// See (broken link) for full details.
enum NameResolutionMode {
  NAME_RESOLUTION_DEFAULT = 0;
  NAME_RESOLUTION_STRICT = 1;
}

// This identifies whether ZetaSQL works in INTERNAL (inside Google) mode,
// or in EXTERNAL (exposed to non-Googlers in the products such as Cloud).
// See (broken link) for details.
enum ProductMode {
  PRODUCT_INTERNAL = 0;
  PRODUCT_EXTERNAL = 1;
}

// This identifies whether statements are resolved in module context (i.e.,
// as a statement contained in a module), or in normal/default context
// (outside of a module).
// See (broken link) for details about module context.
enum StatementContext {
  CONTEXT_DEFAULT = 0;
  CONTEXT_MODULE = 1;
}

// Mode describing how errors should be constructed in the returned
// util::Status.
enum ErrorMessageMode {
  // The error string does not contain a location.
  // An ErrorLocation proto will be attached to the util::Status with
  // a location, when applicable.
  // See error_helpers.h for working with these payloads.
  // See error_location.proto for how line and column are defined.
  ERROR_MESSAGE_WITH_PAYLOAD = 0;

  // The error string contains a suffix " [at <line>:<column>]" when an
  // error location is available.
  ERROR_MESSAGE_ONE_LINE = 1;

  // The error string matches ERROR_MESSAGE_ONE_LINE, and also contains
  // a second line with a substring of the input query, and a third line
  // with a caret ("^") pointing at the error location above.
  ERROR_MESSAGE_MULTI_LINE_WITH_CARET = 2;
}

// Mode describing how parameters are defined and referenced.
enum ParameterMode {
  // Parameters are defined by name (the default) and referenced using the
  // syntax @param_name.
  PARAMETER_NAMED = 0;

  // Parameters are defined positionally and referenced with ?. For example, if
  // two parameters are bound, the first occurrence of ? in the query string
  // refers to the first parameter and the second occurrence to the second
  // parameter.
  PARAMETER_POSITIONAL = 1;

  // No parameters are allowed in the query.
  PARAMETER_NONE = 2;
}
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

syntax = "proto2";

package zetasql;

option java_package = "com.google.zetasql";
option java_multiple_files = true;
option java_outer_classname = "ZetaSqlParseLocationProtos";

// This message stores the start and end byte offsets of a parsed string. It
// also (optionally) stores the name of the file where this parsed string is
// located.
message ParseLocationRangeProto {
  // If present, the name of the file containing the parsed string. It is
  // expected that the start and end of a parsed string would both be located in
  // just one file, so we have only one field to store the filename.
  optional string filename = 1;
  // Byte offset of the first character of the symbol string.
  optional int32 start = 2;
  // Byte offset of the character after the last character of the symbol string.
  optional int32 end = 3;
}
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

syntax = "proto2";

package zetasql;

option java_package = "com.google.zetasql";
option java_outer_classname = "ZetaSQLParser";

message ParseResumeLocationProto {
  // The filename associated with the input string (if any).
  optional string filename = 4;
  // The input string.
  optional string input = 1;
  // The current byte position, the parser will resume from this position in the
  // next round.
  optional int32 byte_position = 2;
  optional bool allow_resume = 3;
}
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

syntax = "proto2";

package zetasql;

import "zetasql/public/type.proto";
import "zetasql/public/value.proto";

option java_package = "com.google.zetasql";
option java_outer_classname = "SimpleConstantProtos";

message SimpleConstantProto {
  repeated string name_path = 1;
  optional TypeProto type = 2;
  optional ValueProto value = 3;
}
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

syntax = "proto2";

package zetasql;

import "zetasql/public/type.proto";

option java_package = "com.google.zetasql";
option java_outer_classname = "SimpleTableProtos";

message SimpleTableProto {
  optional string name = 1;
  optional int64 serialization_id = 2;
  optional bool is_value_table = 3;
  repeated SimpleColumnProto column = 4;
  // Alias name of the table when it is added to the parent catalog.  This is
  // only set when the Table is added to the Catalog using a different name
  // than the Table's name.  This name is not part of the SimpleTable, but
  // will be used as the Table's name in the Catalog.
  optional string name_in_catalog = 5;
  optional bool allow_anonymous_column_name = 6;
  optional bool allow_duplicate_column_names = 7;
}

message SimpleColumnProto {
  optional string name = 1;
  optional TypeProto type = 2;
  optional bool is_pseudo_column = 3;
  optional bool is_writable_column = 4 [default = true];
}
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// LINT: LEGACY_NAMES
syntax = "proto2";

package zetasql;

import "google/protobuf/descriptor.proto";

option cc_enable_arenas = true;
option java_package = "com.google.zetasql";
option java_outer_classname = "ZetaSQLType";

// NEXT_ID: 24
enum TypeKind {
  // User code that switches on this enum must have a default case so
  // builds won't break if new enums get added.
  __TypeKind__switch_must_have_a_default__ = -1;

  // This can be used by consumers to record an unknown type.
  // This is not used internally by ZetaSQL.
  // Most functions that take TypeKind will fail on TYPE_UNKNOWN.
  TYPE_UNKNOWN = 0;

  TYPE_INT32 = 1;
  TYPE_INT64 = 2;
  TYPE_UINT32 = 3;
  TYPE_UINT64 = 4;
  TYPE_BOOL = 5;
  TYPE_FLOAT = 6;
  TYPE_DOUBLE = 7;
  TYPE_STRING = 8;
  TYPE_BYTES = 9;
  TYPE_DATE = 10;
  TYPE_TIMESTAMP = 19;
  TYPE_ENUM = 15;
  TYPE_ARRAY = 16;
  TYPE_STRUCT = 17;
  TYPE_PROTO = 18;

  // TIME and DATETIME is controlled by FEATURE_V_1_2_CIVIL_TIME
  TYPE_TIME = 20;
  TYPE_DATETIME = 21;

  // GEOGRAPHY is controlled by FEATURE_GEOGRAPHY
  TYPE_GEOGRAPHY = 22;

  // NUMERIC is controlled by FEATURE_NUMERIC_TYPE
  TYPE_NUMERIC = 23;
}

// This represents the serialized form of the zetasql::Type.
message TypeProto {
  optional TypeKind type_kind = 1;

  // If the type is not a simple type, then one (and only one) of these
  // will be populated.
  optional ArrayTypeProto array_type = 2;
  optional StructTypeProto struct_type = 3;
  optional ProtoTypeProto proto_type = 4;
  optional EnumTypeProto enum_type = 5;

  // These <file_descriptor_set>s may (optionally) be populated only for
  // the 'outermost' TypeProto when serializing a ZetaSQL Type,
  // in particular when the TypeProto is created using
  // zetasql::Type::SerializeToSelfContainedProto().  They will not be
  // populated for nested TypeProtos.  If populated, they must capture all file
  // dependencies related to the type and all of its descendants, in order
  // be used for deserializing back to the ZetaSQL Type.  If they are not
  // populated, then deserialization can still be done if the relevant
  // FileDescriptorSets are provided to deserialization independent of this
  // proto.  One FileDescriptorSet is created for every distinct DescriptorPool
  // from which an enum or proto type contained within this type originates.
  // For example, serializing a struct with two proto fields from different
  // DescriptorPools would result in two FileDescriptorSets.
  repeated google.protobuf.FileDescriptorSet file_descriptor_set = 6;
}

message ArrayTypeProto {
  optional TypeProto element_type = 1;
}

message StructFieldProto {
  optional string field_name = 1;
  optional TypeProto field_type = 2;
}

message StructTypeProto {
  repeated StructFieldProto field = 1;
}

message ProtoTypeProto {
  // The _full_ name of the proto.
  optional string proto_name = 1;
  optional string proto_file_name = 2;
  // The index of the FileDescriptorSet in the top-level TypeProto that can be
  // used to deserialize this particular ProtoType.
  optional int32 file_descriptor_set_index = 3 [default = 0];
}

message EnumTypeProto {
  // The _full_ name of the enum.
  optional string enum_name = 1;
  optional string enum_file_name = 2;
  // The index of the FileDescriptorSet in the top-level TypeProto that can be
  // used to deserialize this particular EnumType.
  optional int32 file_descriptor_set_index = 3 [default = 0];
}
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// This is a forwarding file.
syntax = "proto2";

package zetasql;

import "zetasql/public/proto/type_annotation.proto";

option java_package = "com.google.zetasql";
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// LINT: LEGACY_NAMES
syntax = "proto2";

package zetasql;

import "google/protobuf/timestamp.proto";

option cc_enable_arenas = true;
option java_package = "com.google.zetasql";
option java_outer_classname = "ZetaSQLValue";

// ValueProto represents the serialized form of the zetasql::Value.
// Unlike zetasql::Value, ValueProto does not carry full type information with
// every instance, and therefore can only be fully interpreted with accompanying
// TypeProto.
message ValueProto {
  // An ordered collection of elements of arbitrary count.
  message Array {
    repeated ValueProto element = 1;
  }

  // A collection of fields. The count, order, and type of the fields is
  // determined by the type associated with this value.
  message Struct {
    repeated ValueProto field = 1;
  }

  message Datetime {
    // Represents bit field encoding of year/month/day/hour/minute/second.
    // See class DatetimeValue in civil_time.h for details of encoding.
    optional int64 bit_field_datetime_seconds = 1;

    // Non-negative fractions of a second at nanosecond resolution.
    optional int32 nanos = 2;
  }

  // Each non-null value will have exactly one of these fields specified.
  // Null values will have no fields set.
  oneof value {
    int32 int32_value = 1;
    int64 int64_value = 2;
    uint32 uint32_value = 3;
    uint64 uint64_value = 4;
    bool bool_value = 5;
    float float_value = 6;
    double double_value = 7;
    string string_value = 8;
    bytes bytes_value = 9;
    int32 date_value = 10;
    // Tag 11 was used for specifying micros timestamps as int64, now obsolete.
    int32 enum_value = 12;
    Array array_value = 13;
    Struct struct_value = 14;
    // Stores a serialized protocol message.
    bytes proto_value = 15;
    google.protobuf.Timestamp timestamp_value = 16;
    Datetime datetime_value = 17;
    // Bit field encoding of hour/minute/second/nanos. See TimeValue class for
    // details.
    int64 time_value = 18;
    // Geography encoded using ::stlib::STGeographyEncoder
    bytes geography_value = 19;
    // Encoded numeric value. For the encoding format see documentation for
    // NumericValue::SerializeAsProtoBytes().
    bytes numeric_value = 20;
    // User code that switches on this oneoff enum must have a default case so
    // builds won't break when new fields are added.
    bool __ValueProto__switch_must_have_a_default = 255;
  }
}
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// This file contains the type annotations supported by ZetaSQL.
//
// These annotations can be used to change the interpretation of proto
// fields when interpreting those fields in ZetaSQL. (e.g. An int32 field can
// be marked as storing a DATE to make it queryable as a date in ZetaSQL.)
//
// These annotations can also be used to indicate that missing fields should
// be treated as NULL values rather than returning the proto field default.
//
// Example:
//
//   import "zetasql/public/proto/type_annotation.proto";
//
//   message SomeMessage {
//     // Date field.
//     optional int32 date = 1 [ (zetasql.format) = DATE ];
//
//     // String field, where ZetaSQL will interpret missing values as NULLs.
//     optional string str = 2 [ (zetasql.use_defaults) = false ];
//
//     // Timestamp field, which can store ZetaSQL NULLs.
//     optional int64 time_millis = 3
//         [ (zetasql.format) = TIMESTAMP_MILLIS,
//           (zetasql.use_defaults) = false ];
//   }
//
//   message OtherMessage {
//     // Interpret missing value as NULLs for all fields in this message.
//     option (zetasql.use_field_defaults) = false;
//
//     optional int64 nullable_int = 1;
//     optional string nullable_string = 2;
//   }

// LINT: LEGACY_NAMES

syntax = "proto2";

package zetasql;

import "google/protobuf/descriptor.proto";

option java_package = "com.google.zetasql";
option java_outer_classname = "TypeAnnotationProto";
option cc_enable_arenas = true;

message FieldFormat {
  enum Format {
    // No format annotation.
    // This is meant as a no-annotation marker in code and should not actually
    // be written as an annotation in .proto files.
    DEFAULT_FORMAT = 0;

    // A ZetaSQL DATE, encoded as days since 1970-01-01 UTC.
    // Can be applied to a field with ctype int32 or an int64.
    //
    // The function DecodeFormattedDate in public/functions/date_time_util.h
    // can be used to decode all supported date formats.
    DATE = 1;

    // A ZetaSQL timestamp.  Timestamps are encoded as elapsed
    // seconds, millis, micros, or nanos since 1970-01-01 00:00:00 UTC.
    // TIMESTAMP_SECONDS is the standard unix time_t type.
    // Should be applied to fields with ctype int64.
    //
    TIMESTAMP_SECONDS = 2;
    TIMESTAMP_MILLIS = 3;
    TIMESTAMP_MICROS = 4;
    TIMESTAMP_NANOS = 5;

    // A ZetaSQL DATE encoded in the MySQL date decimal format,
    // which looks like YYYYMMDD written as an integer.
    // Can be applied to a field with type int32 or an int64.
    //
    // NOTE: The value 0 decodes to NULL in this format.  (Otherwise it would
    // be an invalid date.)
    //
    // The function DecodeFormattedDate in
    // zetasql/public/functions/date_time_util.h
    // can be used to decode all supported date formats.
    //
    DATE_DECIMAL = 6;

    // A ZetaSQL TIME encoded in an 8-byte bit field.
    // See zetasql/public/civil_time.h for encoding methods.
    // Can be applied to a field with ctype int64.
    TIME_MICROS = 7;

    // A ZetaSQL DATETIME encoded in an 8-byte bit field.
    // See zetasql/public/civil_time.h for encoding methods.
    // Can be applied to a field with ctype int64.
    //
    // NOTE: The value 0 decodes to NULL in this format.  (Otherwise it would
    // be an invalid datetime.)
    // To have the default DATETIME value at 1970-01-01 00:00:00, use
    // 138630961515462656 as the default integer value.
    DATETIME_MICROS = 8;

    // A ZetaSQL GEOGRAPHY encoded using either C++'s
    // STGeographyEncoder::Encode (util/geometry/st_lib/stgeography_coder.h) or
    // Java's STGeographyCoder.encode
    // (java/com/google/common/geometry/stlib/STGeographyCoder.java).
    //
    // Can be applied to bytes fields.
    ST_GEOGRAPHY_ENCODED = 9;

    // A ZetaSQL NUMERIC value. These values are encoded as scaled integers in
    // two's complement form with the most significant bit storing the sign. See
    // NumericValue::SerializeAsProtoBytes() for serialization format details.
    //
    // Can be applied to bytes fields.
    NUMERIC = 10;

    // User code that switches on this enum must have a default case so
    // builds won't break if new enums get added.
    __FieldFormat_Type__switch_must_have_a_default__ = -1;
  }
}

message DeprecatedEncoding {
  // DEPRECATED - Encoding has been folded into the Type enum above.
  // This should not be used directly.
  // TODO Remove this once there are no more references.
  enum Encoding {
    option allow_alias = true;

    DEFAULT_ENCODING = 0;
    // Like in FieldFormat, PACKED32 is the wrong name, and people should be
    // using DATE_DECIMAL instead.  This whole enum definition is deprecated
    // though, so this definition probably won't be fixed.
    DATE_PACKED32 = 1;  // This is the wrong name. The format is DATE_DECIMAL.
    DATE_DECIMAL = 1;
    __FieldFormat_Encoding__switch_must_have_a_default__ = -1;
  }
}

extend google.protobuf.FieldOptions {
  // Interpret a proto field using a specific ZetaSQL format, which
  // indicates both the ZetaSQL type and the encoding.
  //
  // When reading this field in SQL, it will act semantically as the specified
  // type rather than the underlying proto field type, and it will
  // be decoded by engines according to the specified encoding.
  // See FieldFormat.Format above.
  //
  // Engines should access this using ProtoType::GetFormatAnnotation rather
  // than extracting it themselves so they handle the deprecated variants
  // below correctly.
  optional FieldFormat.Format format = 68711883;

  // DEPRECATED: This is the legacy name for format.  It is here for
  // compatibility with old proto Descriptors.  It should not be used in
  // new .proto files.
  //
  // zetasql::ProtoType::GetFormatAnnotation will look in both places and use
  // the deprecated annotation if necessary.  If both are present, this one
  // is ignored.
  optional FieldFormat.Format type = 49796453;

  // DEPRECATED.  The encoding has been folded into the Format annotation above.
  // This exists only for legacy .proto files that include this annotation.
  // ProtoType::GetFormatAnnotation automatically merges the legacy encoding
  // annotations into the type annotation so callers can ignore this.
  optional DeprecatedEncoding.Encoding encoding = 62897319;

  // Interpret missing optional scalar fields as NULLs, rather than using
  // the field's default value, if this is set to false.
  //
  // By default, use_defaults = true, and ZetaSQL will use the field's
  // default value when accessing an optional scalar field that isn't present.
  //
  // Notes:
  // 1. In protocol buffers, all optional scalar fields have a default default
  //    (usually 0 or ""), so absence of a declared default has no effect.
  // 2. Repeated fields cannot have absent values, and cannot store NULLs
  //    without using a wrapper message.  See is_wrapper annotation.
  //    use_defaults is invalid on repeated fields.
  // 3. Message types do not have defaults, and not present optional message
  //    fields will always be interpreted as NULL.
  //    use_defaults has no effect on message type fields.
  optional bool use_defaults = 49779519 [default = true];
}

extend google.protobuf.MessageOptions {
  // Same as field-level use_defaults, but applies to all top-level fields in
  // this message.  Does not apply to fields recursively inside sub-messages.
  // Field-level use_defaults overrides message-level use_field_defaults.
  // (Would be called use_defaults, except the name cannot be reused.)
  optional bool use_field_defaults = 49659010 [default = true];
}
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// WARNING: The annotations in this file are intended for use by engine
// implementors.  They are not generally useful for end-users.  They will
// have no effect on zetasql query behavior.
//
// See type_annotation.proto for the annotations that are user-visible and
// are supported at query time.
//
// This file contains additional proto annotations that can be used to
// generate protos that can represent more zetasql types, including structs,
// with full support for SQL-style NULLs.
//
// These annotations can be used internally by engines to generate proto
// messages as wire formats for zetasql types.
//
// These annotations are NOT used during regular zetasql analysis.
// When queries extract a proto field that has these annotations, the
// annotations will be ignored and the returned field type will be the
// raw proto type of the field.
//
// LINT: LEGACY_NAMES

syntax = "proto2";

package zetasql;

import "google/protobuf/descriptor.proto";

option java_package = "com.google.zetasql";
option java_outer_classname = "WireFormatAnnotationProto";

extend google.protobuf.FieldOptions {
  // Indicate that when the containing proto is interpreted as a STRUCT type
  // (because it has an is_struct annotation), this field should have this name
  // in the STRUCT type.  An empty string means this is an anonymous field.
  //
  // This is used when converting a STRUCT type to a proto to support
  // anonymous fields and fields with duplicate names.
  //
  // NOTE: This is NOT interpreted at query time by zetasql.
  optional string struct_field_name = 69661525;

  // Indicate that a message field should be interpreted directly as the
  // contained message type, without processing any message-level annotations.
  //
  // When this is set, message fields will always be interpreted as PROTO type,
  // using the exact proto type from the Descriptor, ignoring any message-level
  // annotations (like is_struct or is_wrapper).
  //
  // This annotation has no effect on fields with non-message types.
  //
  // NOTE: This is NOT interpreted at query time by zetasql.
  optional bool is_raw_proto = 163760138;
}

enum TableType {
  // No TableType annotation.
  // This is meant as a no-annotation marker in code and should not actually
  // be written as an annotation in .proto files.
  DEFAULT_TABLE_TYPE = 0;

  // A normal SQL table, where each row has columns, and each column
  // has a name and a type.
  SQL_TABLE = 1;

  // A value table, where each row has a row type, and the row is just a
  // value of that type, and there is no column name.
  // See (broken link).
  VALUE_TABLE = 2;
}

extend google.protobuf.MessageOptions {
  // Indicate that this message definition is meant as a wrapper object.
  // Normally used to make a contained field nullable.
  //
  // The message should have exactly one field.
  //
  // When interpreting a field with this message type, the wrapper
  // message will be skipped and the contained field's value will be used
  // instead.  If the wrapper is not present, the value is NULL.  If the
  // wrapper is present, the value may also be NULL if the field inside
  // can store NULL values.  Multiple layers of wrappers are allowed.
  //
  // When a field is accessed using has_<field>, this annotation is ignored.
  // has_<field> checks presence of a proto field, not null-ness of a
  // zetasql value.
  //
  // Some examples:
  //
  //   message NullableInt {
  //     option (zetasql.is_wrapper) = true;
  //     optional int32 value [ (zetasql.use_defaults) = false ] = 1;
  //   };
  //   message ArrayOfInt {
  //     option (zetasql.is_wrapper) = true;
  //     repeated int32 value = 1;
  //   }
  //   message ArrayOfNullableInt {
  //     option (zetasql.is_wrapper) = true;
  //     repeated NullableInt value = 1;
  //   }
  //
  // These all have zetasql type int32.
  //   //   Cannot store NULL.
  //   optional int32 int = 1;
  //   //   Stores NULL if not present.
  //   optional int32 nullable_int [ (zetasql.use_defaults) = false ] = 2;
  //   //   Stores NULL if not present or the contained field is not present.
  //   optional NullableInt nullable_int = 3;
  //
  // These all have zetasql type ARRAY<int32>.
  //   //   Array non-nullable, elements non-nullable.
  //   repeated int32 array_of_int = 1;
  //   //   Array non-nullable, elements nullable.
  //   repeated NullableInt array_of_nullable_int = 2;
  //   //   Array nullable, elements non-nullable.
  //   optional ArrayOfInt nullable_array_of_int = 3;
  //   //   Array nullable, elements nullable.
  //   optional ArrayOfNullableInt nullable_array_of_nullable_int = 4;
  //
  // NOTE: This is NOT interpreted at query time by zetasql.
  optional bool is_wrapper = 49730018;

  // Indicate that this proto message should be treated as an anonymous STRUCT
  // type when imported into ZetaSQL.
  //
  // This can be used when a ZetaSQL STRUCT type is exported as a protocol
  // buffer, using a generated protocol buffer descriptor.  When that type
  // is imported back into ZetaSQL, it should become a STRUCT type again,
  // rather than a PROTO type with the name of the generated proto.
  // Struct fields will be ordered in field definition order.
  //
  // Marking a message with is_struct = true does not imply
  // use_field_defaults = false.  The default is still to materialize
  // protocol buffer defaults before converting the value to STRUCT.
  //
  // Example:
  //
  //   message MyKeyValueStruct {
  //     option (zetasql.is_struct) = true;
  //     optional string key = 1;
  //     optional int64 value = 2;
  //   }
  //   // ZetaSQL will interpret this field as ARRAY<STRUCT(string,int64)>.
  //   repeated MyKeyValueStruct keys;
  //
  // NOTE: This is NOT interpreted at query time by zetasql.
  optional bool is_struct = 49727810;

  // Indicates that this proto represents a ZetaSQL table, and indicates
  // whether it is a regular SQL table or a value table.
  //
  // This annotation is used on the top-level proto used to represent a table's
  // row type when a ZetaSQL table is encoded as a proto for storage.
  // This annotation indicates whether the table should be interpreted as a
  // regular table or a value table. This annotation is ignored on non-top-level
  // protos, and is never used or interpreted at query time by zetasql.
  //
  // If table_type=VALUE_TABLE, then the table is a value table, with
  //   proto type by default.  If is_struct is set, the table is a struct
  //   value table.  If is_wrapper is set, the value type is the wrapped type.
  // If table_type=SQL_TABLE, then this table is always a SQL table.
  //   The proto must also have is_struct.  The computed struct type is
  //   flattened into columns.  is_wrapper is not allowed in this case.
  // If table_type is not set, then
  //   If the proto has is_wrapper or is_struct, the table is a value table.
  //   Otherwise, the proto represents a proto, but not one written as a
  //   ZetaSQL table.  Engines should treat the table as a proto value table.
  //
  // Note: When a file is written for a proto value table using a user's proto,
  // a table_type=VALUE_TABLE annotation should be added into the proto so the
  // file can be identified as a ZetaSQL table.  At read time, that annotation
  // should be stripped to get back to the user's original proto.
  optional TableType table_type = 86830980;
}

// This is a hack so that the generated module has at least one Descriptor in
// it, so code that needs to reference this module can use that Descriptor to
// get a reference to the file's FileDescriptor.
// Otherwise, this should not be used.
message WireFormatAnnotationEmptyMessage {}
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

syntax = "proto2";

package zetasql;

option java_package = "com.google.zetasql.resolvedast";
option java_multiple_files = true;
option java_outer_classname = "ZetaSQLResolvedASTEnums";

// These are enums that are used in the Resolved AST nodes.
// Enum type and values under <cpp_class_name>Enums will be "imported" to the
// corresponding C++ class as typedefs and static consts, so that they can be
// referred to under the class name.
// E.g. ResolvedSubqueryExprEnums::SubqueryType::SCALAR can be referred to with
// ResolvedSubqueryExpr::SCALAR.

message ResolvedSubqueryExprEnums {
  enum SubqueryType {
    SCALAR = 0;
    ARRAY = 1;
    EXISTS = 2;
    IN = 3;
  }
}

message ResolvedJoinScanEnums {
  enum JoinType {
    INNER = 0;
    LEFT = 1;
    RIGHT = 2;
    FULL = 3;
  }
}

message ResolvedSetOperationScanEnums {
  enum SetOperationType {
    UNION_ALL = 0;
    UNION_DISTINCT = 1;
    INTERSECT_ALL = 2;
    INTERSECT_DISTINCT = 3;
    EXCEPT_ALL = 4;
    EXCEPT_DISTINCT = 5;
  }
}

message ResolvedSampleScanEnums {
  enum SampleUnit {
    ROWS = 0;
    PERCENT = 1;
  }
}

message ResolvedOrderByItemEnums {
  enum NullOrderMode {
    ORDER_UNSPECIFIED = 0;
    NULLS_FIRST = 1;
    NULLS_LAST = 2;
  }
}

message ResolvedCreateStatementEnums {
  enum CreateScope {
    CREATE_DEFAULT_SCOPE = 0;
    CREATE_PRIVATE = 1;
    CREATE_PUBLIC = 2;
    CREATE_TEMP = 3;
  }
  enum CreateMode {
    CREATE_DEFAULT = 0;
    CREATE_OR_REPLACE = 1;
    CREATE_IF_NOT_EXISTS = 2;
  }
  enum SqlSecurity {
    SQL_SECURITY_UNSPECIFIED = 0;
    SQL_SECURITY_DEFINER = 1;
    SQL_SECURITY_INVOKER = 2;
  }
  enum DeterminismLevel {
    DETERMINISM_UNSPECIFIED = 0;
    DETERMINISM_DETERMINISTIC = 1;
    DETERMINISM_NOT_DETERMINISTIC = 2;
    DETERMINISM_IMMUTABLE = 3;
    DETERMINISM_STABLE = 4;
    DETERMINISM_VOLATILE = 5;
  }
}

message ResolvedBeginStmtEnums {
  enum ReadWriteMode {
    MODE_UNSPECIFIED = 0;
    MODE_READ_ONLY = 1;
    MODE_READ_WRITE = 2;
  }
}

message ResolvedWindowFrameEnums {
  enum FrameUnit {
    ROWS = 0;
    RANGE = 1;
  }
}

message ResolvedWindowFrameExprEnums {
  enum BoundaryType {
    UNBOUNDED_PRECEDING = 0;
    OFFSET_PRECEDING = 1;
    CURRENT_ROW = 2;
    OFFSET_FOLLOWING = 3;
    UNBOUNDED_FOLLOWING = 4;
  }
}

message ResolvedInsertStmtEnums {
  // This defines the behavior of INSERT when there are duplicate rows.
  // "Duplicate" generally mean rows with identical primary keys.
  enum InsertMode {
    OR_ERROR = 0;    // Give an error.
    OR_IGNORE = 1;   // Skip the duplicate row.
    OR_REPLACE = 2;  // Replace the row.
    OR_UPDATE = 3;   // Merge inserted columns into the existing row.
                     // Preseve existing values of unreferenced columns.
  }
}

message ResolvedMergeWhenEnums {
  enum MatchType {
    MATCHED = 0;                // WHEN MATCHED ... THEN clause.
    NOT_MATCHED_BY_SOURCE = 1;  // WHEN NOT MATCHED BY SOURCE ... THEN clause.
    NOT_MATCHED_BY_TARGET = 2;  // WHEN NOT MATCHED BY TARGET ... THEN clause.
  }

  enum ActionType {
    INSERT = 0;
    UPDATE = 1;
    DELETE = 2;
  }
}

// Note: These enums are imported in both ResolvedArgument{Def,Ref}, using a
// hack in gen_resolved_ast.py.
message ResolvedArgumentDefEnums {
  // This describes the type of argument in a CREATE FUNCTION signature.
  enum ArgumentKind {
    SCALAR = 0;         // An argument to a scalar (non-aggregate) function.
    AGGREGATE = 1;      // An aggregate argument to an aggregate function.
    NOT_AGGREGATE = 2;  // A non-aggregate argument to an aggregate function.
  }
}

message ResolvedFunctionCallBaseEnums {
  enum ErrorMode {
    DEFAULT_ERROR_MODE = 0;  // Return errors as usual.
    SAFE_ERROR_MODE = 1;     // If this function call returns a semantic error
                             // (based on input data, not transient server
                             // problems), return NULL instead of an error.
  }
}

message ResolvedNonScalarFunctionCallBaseEnums {
  enum NullHandlingModifier {
    DEFAULT_NULL_HANDLING = 0;  // Let each function decide how to handle nulls.
    IGNORE_NULLS = 1;
    RESPECT_NULLS = 2;
  }
}

message ResolvedAggregateHavingModifierEnums {
  enum HavingModifierKind {
    INVALID = 0;
    MAX = 1;
    MIN = 2;
  }
}

message ResolvedStatementEnums {
  // This describes the set of operations performed on objects.
  // It is currently only used for ResolvedColumns.
  // It can be READ, WRITE or both. This enum is a bitmap and values are
  // intended to be bitwise OR'd together to produce the full set of operations.
  enum ObjectAccess {
    NONE = 0;        // b0000
    READ = 1;        // b0001
    WRITE = 2;       // b0010
    READ_WRITE = 3;  // b0011
  }
}

// LINT: LEGACY_NAMES
message ResolvedImportStmtEnums {
  // This describes the type of object imported in an IMPORT statement.
  enum ImportKind {
    MODULE = 0;
    PROTO = 1;

    // User code that switches on this enum must have a default case so
    // builds won't break if new enums get added.  The user default code
    // must also throw an error, since new import types will be implicitly
    // unsupported.
    __ImportKind__switch_must_have_a_default__ = -1;
  }
}

// Enumerations for some of the foreign key column and table constraint
// attributes.
message ResolvedForeignKeyEnums {
  // FOREIGN KEY (a) REFERENCES t (r) MATCH <MatchMode>.
  enum MatchMode {
    SIMPLE = 0;
    FULL = 1;
    NOT_DISTINCT = 2;
  }

  // FOREIGN KEY (a) REFERENCES t (r) ON UPDATE|DELETE <ActionOperation>.
  enum ActionOperation {
    NO_ACTION = 0;
    RESTRICT = 1;
    CASCADE = 2;
    SET_NULL = 3;
  }
}
//
// Copyright 2019 ZetaSQL Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Common types for serializing the ResolvedAST
syntax = "proto2";

package zetasql;

import "zetasql/public/parse_location_range.proto";
import "zetasql/public/type.proto";
import "zetasql/public/value.proto";

option java_package = "com.google.zetasql";
option java_multiple_files = true;
option java_outer_classname = "ZetaSQLSerialization";

// Reference to a ResolvedColumn.
message ResolvedColumnProto {
  optional int64 column_id = 1;
  optional string table_name = 2;
  optional string name = 3;
  optional TypeProto type = 4;
}

message ValueWithTypeProto {
  optional TypeProto type = 1;
  optional ValueProto value = 2;
}

// Reference to a table.
message TableRefProto {
  optional string name = 1;
  optional int64 serialization_id = 2;
  optional string full_name = 3;
}

// Reference to a model.
message ModelRefProto {
  optional string name = 1;
  optional int64 serialization_id = 2;
  optional string full_name = 3;
}

// Reference to a connection
message ConnectionRefProto {
  optional string name = 1;
  optional string full_name = 3;
}

// Reference to a named constant.
message ConstantRefProto {
  // Full name of the function, e.g., catalog1.catalog2.Constant.
  optional string name = 1;
}

// Reference to a function.
message FunctionRefProto {
  // TODO: Optimize this by generating unique serialization IDs.
  // Full name of the function, e.g., group:pathname.
  optional string name = 1;
}

// Reference to a table-valued function.
message TableValuedFunctionRefProto {
  // Full name of the function, e.g., group:pathname.
  optional string name = 1;
}

message ResolvedNodeProto {
  // Parse location range if present in the ResolvedNode.
  optional ParseLocationRangeProto parse_location_range = 1;
}

// Reference to a proto field descriptor.
message FieldDescriptorRefProto {
  optional ProtoTypeProto containing_proto = 1;
  optional int32 number = 2;
}

// Reference to a proto2::OneofDescriptor, which describes the fields of an
// Oneof.
message OneofDescriptorRefProto {
  optional ProtoTypeProto containing_proto = 1;

  // 0-based offset which aligns with the order Oneof fields are defined in the
  // containing message.
  optional int32 index = 2;
}

message ProcedureRefProto {
  optional string name = 1;
}
